/*! For license information please see gc.js.LICENSE.txt */
!function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/core.service.js")}({"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/core.service.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./factories/debug.factory */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js");\n/* harmony import */ var _models_info_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/info.model */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/info.model.js");\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factories/utils.factory */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js");\n\n// a placeholder so the build process replace\n// it with some ENV variables\nglobal.GC_CLIENT_ENV = {"CLIENT_ENV_SSR_WIDGET_URL_OLD":"https://widget.gotchosen.com","CLIENT_ENV_CACHE_API":"https://cache-api.gotchosen.com","CLIENT_ENV_WIDGET_BUCKET_URL_NEW":"https://amp-cdn.gotchosen.com","CLIENT_ENV_ENV_NAME":"production","CLIENT_ENV_WIDGET_BUCKET_NEW":"amp-cdn.gotchosen.com","CLIENT_ENV_SSR_WIDGET_URL_NEW":"https://amp-carousel.gotchosen.com","CLIENT_ENV_WIDGET_BUCKET_URL_OLD":"https://cdn.gotchosen.com","CLIENT_ENV_WIDGET_BUCKET_OLD":"cdn.gotchosen.com","CLIENT_ENV_GCJS_BUCKET":"cdn.gotchosen.com"};\n\n// factories dependencies\n\n\n// client model dependency\n\n\nconst publisherSettings = {"publisher_site":{"id":520,"host":"https://realclearpolitics.com","ad_unit_name":"realclearpolitics.com"},"active":true,"widget_version":2,"widget_lazy_loading":false,"gcid":"GC_e4431c0a82261742f007d36f767de82097f19bc6","disable_widget":false,"disable_ads":null,"utm_source":null,"gdpr":null,"enable_cmp":true,"googlefc":null,"force_widget_full_width":null,"force_renew_cache":null,"cache_buster":1682015705158,"widget_target_enabled":false,"widget_target_type":null,"widget_target_name":null,"widget_target_value":null,"widget_start_at":null,"widget_end_at":null,"carousel_auto_rotation":null,"enable_single_ad_section":null,"enable_top_single_ad_section":null,"enable_top_single_ad_section_mobile":null,"ads_delay":null,"widget_delay":null,"widget_theme":null,"networks_order":null,"get_from_ssr":false,"enable_ads_removal":null,"family_group_profile":"PAPA","enable_bottom_ad":true,"enable_bottom_ad_mobile":null,"bottom_ad_refresh_time":null,"nofill_ad_refresh_time":18000,"disable_auto_install":false,"enable_utm_source_report":false,"show_advertisement_label":true,"negative_targets":[],"negative_tags":{"css_selector":{"enabled":null,"start_at":null,"end_at":null,"key":null,"value":null},"post_message":{"enabled":null,"start_at":null,"end_at":null,"key":null,"value":null},"javascript":{"enabled":null,"start_at":null,"end_at":null,"key":null,"value":null},"metatag":{"enabled":null,"start_at":null,"end_at":null,"key":null,"value":null}}}\nconsole.log(\'CoreService->constructor(): publisherSettings\', publisherSettings);\n\n// a placeholder so the build process replace\n// it with publisher object data\nglobal.GC_CLIENT_SETTINGS = new _models_info_model__WEBPACK_IMPORTED_MODULE_1__["default"](publisherSettings);\n\n// factories dependencies\n\n\n// extended dependencies\nconst customModules = {\n  \'EventsModule\': __webpack_require__(/*! ./modules/events.module */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/events.module.js"),\n  \'WidgetModule\': __webpack_require__(/*! ./modules/widget.module */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/widget.module.js"),\n  \'CmpModule\': __webpack_require__(/*! ./modules/cmp.module */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/cmp.module.js"),\n  \'NegativeTargetingModule\': __webpack_require__(/*! ./modules/negative-targeting.module */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/negative-targeting.module.js")\n  \n  // This is a placeholder that will be replace by the custom\n  // modules that needs to be build withing the publisher GC.JS\n  //{{customModules}}\n};\n\nconst extendsModules = [];\n\nif (!global.GcCoreServiceInstances) {\n  global.GcCoreServiceInstances = {};\n}\n\nconsole.log(\'CoreService->constructor(): global.GC_CLIENT_SETTINGS\', global.GC_CLIENT_SETTINGS);\nconsole.log(\'CoreService->constructor(): global.GC_CLIENT_ENV\', global.GC_CLIENT_ENV);\nconsole.log(\'CoreService->constructor(): customModules\', customModules);\n\nfor (let i in customModules) {\n  extendsModules.push(customModules[i].default);\n}\n\nconsole.log(\'core.service->extendsModules\', extendsModules);\n\nclass CoreService extends aggregation.apply(null, extendsModules) {\n  \n  constructor() {\n    \n    // console.log(\'CoreService->constructor()\')\n    \n    super();\n    \n    // global.console.timeEnd(\'GC: Time GC.JS is ready\')\n    \n    this.cacheBuster = global.GC_CLIENT_SETTINGS.cache_buster || new Date().toJSON().slice(0, 13).replace(/[T-]/g, \'\');\n    this.gcid = global.GC_CLIENT_SETTINGS.gcid;\n    this.hasTriggeredEnableAds = false;\n    \n    if (!this.gcid || this.gcid.indexOf(\'GC_\') === -1 || this.gcid.length <= 6) {\n      throw new Error(`You must provide a valid GCID.`);\n    }\n    \n  }\n  \n  /**\n   * Method to trigger a Core like: this.exec(\'onInit\', function() {})\n   * This is was created to keep the new GC.JS 100% compatible with older versions\n   */\n  async exec() {\n    \n    console.log(\'CoreService->exec(): arguments\', arguments);\n    \n    try {\n      if (this instanceof CoreService) {\n        const args = [];\n        \n        // transcluding the arguments into another array so it can be handled\n        for (let i in arguments) {\n          args.push(arguments[i]);\n        }\n        \n        // extracting the method name from arguments\n        const method = args.splice(0, 1)[0];\n        \n        console.log(\'CoreService->exec():method\', method, args, this);\n        \n        // is the method defined?\n        if (this[method] instanceof Function) {\n          return this[method].apply(this, args);\n        }\n        else {\n          throw new Error(\'EXEC(): {\' + method + \'} is not a API method!\');\n        }\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to expand the widget height to show the bottom AD\n   */\n  expandWidgetHeight(widgetId, isDoubleBottomAd) {\n    \n    console.log(\'CoreService->expandWidgetHeight(): widgetId\', widgetId);\n    \n    try {\n      \n      let widgetModel = null;\n      \n      for (let i in this.widgets) {\n        if (this.widgets[i].widget_id === widgetId) {\n          widgetModel = this.widgets[i];\n          break;\n        }\n      }\n      \n      if (widgetModel) {\n        widgetModel.expandWidgetHeight(isDoubleBottomAd);\n      }\n      \n      console.log(\'CoreService->expandWidgetHeight(): widgetModel\', widgetModel);\n      \n    }\n    catch (e) {\n    \n    }\n  }\n  \n  /**\n   * Method to reverse the expanse of the widget height\n   */\n  removeExpandWidgetHeight(widgetId) {\n    \n    console.log(\'CoreService->removeExpandWidgetHeight(): widgetId\', widgetId);\n    \n    try {\n      \n      let widgetModel = null;\n      \n      for (let i in this.widgets) {\n        if (this.widgets[i].widget_id === widgetId) {\n          widgetModel = this.widgets[i];\n          break;\n        }\n      }\n      \n      if (widgetModel) {\n        widgetModel.removeExpandWidgetHeight();\n      }\n      \n      console.log(\'CoreService->removeExpandWidgetHeight(): widgetModel\', widgetModel);\n      \n    }\n    catch (e) {\n    \n    }\n  }\n  \n  /**\n   * Method to destroy all information on CoreService()\n   */\n  destroyCoreService() {\n    try {\n      if (this.destroyWidgetModule) {\n        this.destroyWidgetModule();\n      }\n    }\n    catch (e) {\n      console.error(e);\n    }\n  }\n  \n  /**\n   * Method to SHOW the funding choices CMP\n   */\n  showGdprConsent() {\n    \n    console.log(\'CoreService->showGdprConsent()\');\n    \n    try {\n      this.showCmpMessage();\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to HIDE the funding choices CMP\n   */\n  hideGdprConsent() {\n    \n    console.log(\'CoreService->hideGdprConsent()\');\n    \n    try {\n      this.hideCmpMessage();\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to start the GC.JS API\n   */\n  async init(gcid, options) {\n    \n    console.log(\'CoreService->init(): gcid\', gcid);\n    console.log(\'CoreService->init(): options\', typeof options, options);\n    \n    try {\n      \n      let hasBlockedByNegativeTarget = false;\n      \n      if (typeof gcid === \'object\') {\n        options = gcid;\n      }\n      \n      if (!options) {\n        options = {};\n      }\n      \n      console.log(\'CoreService->init(): options\', options);\n      \n      // overwriting the publisher default options with the custom properties\n      // provided on "gc(\'init\', {gcid}, {options})"\n      if (typeof options === \'object\') {\n        console.log(\'CoreService->init(): global.GC_CLIENT_SETTINGS.fill\', options);\n        global.GC_CLIENT_SETTINGS.fill(options);\n      }\n      \n      // overwriting the publisher default options with the custom properties\n      // provided on the URL\n      const urlParams = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].getUrlParams();\n      \n      console.log(\'CoreService->init(): urlParams\', urlParams);\n      \n      if (urlParams) {\n        global.GC_CLIENT_SETTINGS.fill(urlParams);\n      }\n      \n      if (global.GC_CLIENT_SETTINGS.disable_widget) {\n        throw new Error(\'Forcing disabling GC Widget\');\n      }\n      \n      if (global.GC_CLIENT_SETTINGS.widget_delay) {\n        await new Promise(resolve => {\n          setTimeout(() => {\n            resolve();\n          }, global.GC_CLIENT_SETTINGS.widget_delay);\n        });\n      }\n      \n      // console.log(\'CoreService->init(): global.GC_CLIENT_SETTINGS\', global.GC_CLIENT_SETTINGS)\n      if (customModules.NegativeTargetingModule) {\n        hasBlockedByNegativeTarget = await this.startNegativeTarget();\n      }\n      \n      console.log(\'CoreService->init(): global.GC_CLIENT_SETTINGS\', global.GC_CLIENT_SETTINGS);\n      \n      if (hasBlockedByNegativeTarget === false) {\n        \n        try {\n          \n          await this.startCmp(options);\n          \n          if (global.GC_CLIENT_SETTINGS.enable_utm_source_report) {\n            this.registerReferrerHost(global.GC_CLIENT_SETTINGS);\n          }\n          \n          await _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].injectTag(`https://${global.GC_CLIENT_ENV.CLIENT_ENV_GCJS_BUCKET}/gcjs/style.css?cb=${this.cacheBuster}`, \'link\');\n          \n          // global.console.timeEnd(\'GC: Time WEBCURTAIN function is ready\')\n          this.startWidget(options ? options.widgets : null);\n          \n        }\n        catch (e) {\n          throw e;\n        }\n      }\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to deal with the referrer/source\n   */\n  async registerReferrerHost(options) {\n    \n    try {\n      \n      const localStorageKey = `gc-referrer-source:${this.gcid}`;\n      const localStorageListKey = `gc-referrer-list:${this.gcid}`;\n      const urlParams = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].getUrlParams();\n      const localReferrer = JSON.parse(global.localStorage.getItem(localStorageKey));\n      const now = Date.now();\n      \n      console.log(\'CoreService->registerReferrerHost(): localReferrer\', localReferrer);\n      \n      let referrer = document.referrer;\n      let host = null;\n      let param_utm_source = null;\n      let utm_source = null;\n      \n      if ((\n            options && options.utm_source\n          ) || urlParams.utm_source) {\n        param_utm_source = decodeURIComponent((\n                                                options && options.utm_source\n                                              ) || urlParams.utm_source).toLowerCase();\n      }\n      \n      if (referrer) {\n        referrer = referrer + \'/\';\n        \n        if (referrer.indexOf(\'http\') === -1) {\n          referrer = \'http://\' + referrer;\n        }\n        \n        referrer = referrer.match(/((\\w{1,253})(((\\.[A-z]{1,63}){1})(\\.[A-z]{1,2})?)(:[0-9]{2,5})?)\\//i);\n        \n        console.log(\'CoreService->registerReferrerHost(): referrer\', referrer);\n        \n        if (referrer && referrer.length && referrer[1]) {\n          host = referrer[1];\n          \n          if (host) {\n            utm_source = host.split(\'.\')[0];\n          }\n          \n        }\n        \n        if (!utm_source || (\n          utm_source && global.location.host.indexOf(utm_source) > -1\n        )) {\n          host = null;\n          utm_source = null;\n        }\n        \n      }\n      \n      if (param_utm_source) {\n        utm_source = param_utm_source;\n      }\n      \n      console.log(\'CoreService->registerReferrerHost(): utm_source\', utm_source, param_utm_source);\n      \n      if (localReferrer) {\n        \n        const localStorageSource = localReferrer.utm_source.toLowerCase();\n        \n        if (global.location.host.indexOf(localStorageSource) === -1) {\n          console.log(\'CoreService->registerReferrerHost(): now - localReferrer.updated_at\', (\n            now - localReferrer.updated_at\n          ));\n          \n          if ((\n                now - localReferrer.updated_at\n              ) < 60000) {\n            \n            if (!host && param_utm_source === localStorageSource) {\n              host = localReferrer.host;\n            }\n            \n            utm_source = param_utm_source || utm_source || localStorageSource;\n            \n          }\n          \n        }\n        \n      }\n      \n      console.log(\'CoreService->registerReferrerHost(): host\', host);\n      \n      if (utm_source) {\n        \n        const escapedSourceName = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].getEscapedName(utm_source);\n        let listSavedSources = JSON.parse(global.localStorage.getItem(localStorageListKey));\n        \n        if (!listSavedSources) {\n          listSavedSources = [];\n        }\n        \n        if (listSavedSources.indexOf(escapedSourceName) === -1) {\n          \n          listSavedSources.push(escapedSourceName);\n          \n          global.localStorage.setItem(localStorageListKey, JSON.stringify(listSavedSources));\n          \n          _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].getAjax({\n            url: `${global.GC_CLIENT_ENV.CLIENT_ENV_CACHE_API}/register-referrer`,\n            data: {\n              gcid: this.gcid,\n              host: host,\n              source: utm_source\n            }\n          });\n          \n        }\n        \n        const response = {\n          host: host,\n          utm_source: utm_source,\n          updated_at: Date.now()\n        };\n        \n        global.localStorage.setItem(localStorageKey, JSON.stringify(response));\n        \n        setInterval(() => {\n          response.updated_at = Date.now();\n          global.localStorage.setItem(localStorageKey, JSON.stringify(response));\n        }, 5000);\n        \n      }\n      else if (localReferrer) {\n        global.localStorage.removeItem(localStorageKey);\n      }\n      \n      console.log(\'CoreService->registerReferrerHost(): utm_source\', utm_source);\n      \n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n}\n\nfunction aggregation(baseClass, ...mixins) {\n  \n  // console.log(\'aggregation\', baseClass, mixins);\n  \n  class base extends baseClass {\n    constructor(...args) {\n      super(...args);\n      mixins.forEach((mixin) => {\n        copyProps(this, (\n          new mixin\n        ));\n      });\n    }\n  }\n  \n  let copyProps = (target, source) => {  // this function copies all properties and symbols, filtering out some special ones\n    Object.getOwnPropertyNames(source)\n      .concat(Object.getOwnPropertySymbols(source))\n      .forEach((prop) => {\n        if (!prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) {\n          Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n        }\n      });\n  };\n  mixins.forEach((mixin) => { // outside contructor() to allow aggregation(A,B,C).staticFunction() to be called etc.\n    copyProps(base.prototype, mixin.prototype);\n    copyProps(base, mixin);\n  });\n  return base;\n}\n\n(\n  async function (nameSpace) {\n    \n    // Was the gc() method initialized?\n    if (nameSpace in global && global[nameSpace] in global) {\n      \n      // global.console.time(\'GC: Time GC.JS is ready\')\n      // global.console.time(\'GC: Time WEBCURTAIN function is ready\')\n      // global.console.time(\'GC: Time WIDGET is injected\')\n      // global.console.time(\'GC: Time CAROUSEL is ready\')\n      // global.console.time(\'GC: Time PREBID is ready\')\n      // global.console.time(\'GC: Time to request BottomAd\')\n      // global.console.time(\'GC: Time to request CarouselAd\')\n      \n      const uniqueNameSpace = global[nameSpace];\n      const apiUniqueNameSpace = uniqueNameSpace.toUpperCase();\n      const asyncCalls = \'q\' in global[uniqueNameSpace] ? global[uniqueNameSpace].q : null;\n      \n      // Making the GC API public\n      const GC = global[apiUniqueNameSpace] = new CoreService();\n      \n      // creating an alias for GC.init() in order to keep compatible with old GC tags\n      GC.webcurtain = function (gcid, options) {\n        GC.init(gcid, options);\n      };\n  \n      window.dataLayer = window.dataLayer || [];\n      window.gc_dataLayer = window.dataLayer;\n      \n      // is there Google Analytics on page?\n      if (!window.gtag) {\n  \n        window.gtag = function () {\n          window.dataLayer.push(arguments);\n        };\n  \n        _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].injectTag(\'https://www.googletagmanager.com/gtag/js?id=G-1CPTFB632T\');\n  \n        // using the GA instance already inject to prevent double Lib\n        /*global.ga(\'create\', \'UA-161177421-1\', \'auto\', {name: \'gcGcJsApi\'});\n        global.ga(\'gcGcJsApi.send\', {\n          hitType: \'event\',\n          eventCategory: `[GC.JS-SSR][${global.GC_CLIENT_ENV.CLIENT_ENV_ENV_NAME}]`,\n          eventAction: \'GC.JS Has loaded\',\n          eventLabel: UtilsFactory.getUrlHostDomain(global.location.host)\n        });*/\n        \n      }\n      else {\n        \n        // if there is not GA on page, inject a new instance and register the user access\n        /*UtilsFactory.injectTag(\'https://www.google-analytics.com/analytics.js\', \'script\').then(() => {\n          global.ga(\'create\', \'UA-161177421-1\', \'auto\', {name: \'gcGcJsApi\'});\n          global.ga(\'gcGcJsApi.send\', {\n            hitType: \'event\',\n            eventCategory: \'[GC.JS-SSR]\',\n            eventAction: \'GC.JS Has loaded\',\n            eventLabel: global.location.host\n          });\n        });*/\n  \n  \n      }\n  \n      window.gtag(\'js\', new Date());\n      window.gtag(\'config\', \'G-1CPTFB632T\', {name: \'gcGcJsApi\'});\n  \n      window.gc_gtag = (event, category, url) => {\n    \n        console.log(\'[GC.JS] window.gc_gtag(): event, category, url\', {event, category, url, host: global.GC_CLIENT_SETTINGS.publisher_site.host});\n        console.log(\'[GC.JS] window.gc_gtag(): window.gtag\', window.gtag);\n    \n        window.gtag(\'event\', event, {\n          \'event_category\': category,\n          \'event_label\': _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].getUrlHostDomain(global.GC_CLIENT_SETTINGS.publisher_site.host),\n          // \'non_interaction\': true\n        });\n        \n      }\n      \n      window.gc_gtag(\n        \'GC.JS Has loaded\',\n        `[GC.JS-SSR][${global.GC_CLIENT_ENV.CLIENT_ENV_ENV_NAME.toUpperCase()}]`,\n        global.location.host\n      );\n      \n      // was any async method called?\n      if (asyncCalls) {\n        \n        // call asynchronously all pre-registered call\n        for (let i in asyncCalls) {\n          console.log(\'GC.exec.apply\', i, asyncCalls[i]);\n          GC.exec.apply(GC, asyncCalls[i]);\n        }\n        \n        // rewrite the GC method for asynchronous API calls: Ex.: gc(\'onInit\', function() {})\n        global[uniqueNameSpace] = function () {\n          GC.exec.apply(GC, arguments);\n        };\n      }\n      \n      // console.log(\'[GC.JS] global\', global)\n      console.log(\'[GC.JS] nameSpace\', nameSpace);\n      console.log(\'[GC.JS] uniqueNameSpace\', uniqueNameSpace);\n      console.log(\'[GC.JS] apiUniqueNameSpace\', apiUniqueNameSpace);\n      console.log(\'[GC.JS] global[uniqueNameSpace]\', global[uniqueNameSpace]);\n      console.log(\'[GC.JS] asyncCalls\', asyncCalls);\n      console.log(\'[GC.JS] global[apiUniqueNameSpace]\', global[apiUniqueNameSpace]);\n      \n    }\n    else {\n      global.GcCoreServiceInstances[global.GC_CLIENT_SETTINGS.gcid] = new CoreService();\n      console.log(\'[GC.JS] global.GcCoreServiceInstances\', global.GcCoreServiceInstances);\n    }\n    \n  }\n)(\'GotChosenObject\');\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../var/task/node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/core.service.js?')},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {class DebugFactory {\n  \n  constructor() {\n    \n    this.styles = {\n      error: ['background: red', 'padding: 5px', 'color: white', 'display: block'].join(';'),\n      warn: ['background: yellow', 'padding: 5px', 'color: black', 'display: block'].join(';'),\n      info: ['background: green', 'padding: 5px', 'color: white', 'display: block'].join(';')\n    };\n  }\n  \n  getArgs(args) {\n    \n    const finalArgs = ['[GC.JS]'];\n    \n    for (let i in args) {\n      if (args[i] !== 'styled' && args[i] !== 'forced') {\n        finalArgs.push(args[i]);\n      }\n    }\n    \n    return finalArgs;\n  }\n  \n  displayLog(type, args) {\n    \n    const styled = args[1] === 'styled' || args[2] === 'styled';\n    const forced = args[1] === 'forced' || args[2] === 'forced';\n    let logsEnabled = false;\n    \n    if (global.localStorage) {\n      if (global.localStorage.getItem('gc-force-enable-logs') === 'true') {\n        logsEnabled = true;\n      }\n      if (global.localStorage.getItem('gc-force-enable-logs') === 'false') {\n        logsEnabled = false;\n      }\n    }\n    else if (global.GC_CLIENT_ENV) {\n      logsEnabled = global.GC_CLIENT_ENV.CLIENT_ENV_ENV_NAME !== 'production';\n    }\n    \n    if (forced || logsEnabled) {\n      if (styled && this.styles[type]) {\n        console[type](`%c ${this.getArgs(args).join(', ')}`, this.styles[type]);\n      }\n      else if (type in console) {\n        console[type].apply(null, this.getArgs(args));\n      }\n    }\n  }\n  \n  log() {\n    this.displayLog('log', arguments);\n  }\n  \n  error() {\n    this.displayLog('error', arguments);\n  }\n  \n  warn() {\n    this.displayLog('warn', arguments);\n  }\n  \n  info() {\n    this.displayLog('info', arguments);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (new DebugFactory());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../var/task/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _debug_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n\n\n// factories dependencies\n\n\nclass UtilsFactory {\n  \n  constructor() {\n    this.storageLocal = {};\n  }\n  \n  isBrowser() {\n    try {\n      return !!window;\n    }\n    catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Method to parse a string when json is expected\n   */\n  tryParseJSON(jsonString) {\n    try {\n      try {\n        \n        const obj = JSON.parse(jsonString);\n        \n        if (obj && typeof obj === 'object') {\n          return obj;\n        }\n      }\n      catch (e) {\n        return false; // null is an object, so we use a boolean for simplicity\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to parse the value and return the value type\n   */\n  parseValue(value) {\n    \n    // Debug.log('UtilsFactory->parseValue(): ', value)\n    \n    try {\n      if (typeof value === 'string') {\n        \n        // making some standard values\n        if (value === 'false') {\n          return false;\n        }\n        else if (value === 'true') {\n          return true;\n        }\n        else if (value === 'null') {\n          return null;\n        }\n        else if (value.indexOf('[') === 0) {\n          value = this.tryParseJSON(value);\n          if (typeof value === 'object') {\n            return value;\n          }\n          else {\n            return [];\n          }\n        }\n        else if (value.indexOf('{') === 0) {\n          value = this.tryParseJSON(value);\n          if (typeof value === 'object') {\n            return value;\n          }\n          else {\n            return {};\n          }\n        }\n        else if (!isNaN(value)) {\n          return parseInt(value);\n        }\n        \n      }\n      \n      return value;\n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to get the params from a full URL\n   */\n  getUrlParams(url) {\n    \n    // Debug.log('UtilsFactory->getUrlParams(): ', url)\n    \n    try {\n      const paramsObject = {};\n      \n      url = url || global.location.href;\n      \n      // check if has any search param from URL, if so, build an object\n      // within the paramsObject\n      if (url) {\n        \n        // spliting the URL to get the params piece\n        url = url.split('?');\n        \n        // is there a params piece?\n        if (url[1]) {\n          \n          // spliting the params itself\n          url = url[1].split('&');\n          \n          // looping through params\n          for (let i in url) {\n            \n            // breaking key=value\n            const param = url[i].split('=');\n            \n            // parse value to return the right type:\n            paramsObject[param[0]] = this.parseValue(param[1]);\n            \n          }\n        }\n        \n      }\n      \n      return paramsObject;\n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to serialize an object into URL params (Ex.: key1=value1&key2=value2\n   */\n  serializeObject(params) {\n    \n    try {\n      let paramsString = '';\n      \n      if (typeof params === 'object') {\n        for (let i in params) {\n          const param = params[i];\n          if (param !== undefined && param !== null && typeof param !== 'object' && typeof param !== 'function') {\n            if (Array.isArray(param)) {\n              // paramsString += (paramsString ? '&' : '') + i + '=' + (JSON.stringify(param))\n              for (let x in param) {\n                paramsString += (paramsString ? '&' : '') + i + '=' + (param[x].toString());\n              }\n            }\n            else {\n              paramsString += (paramsString ? '&' : '') + i + '=' + (param.toString());\n            }\n          }\n        }\n      }\n      \n      return paramsString;\n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to check if an element is within the viewport\n   */\n  isElementIntoViewport(el, bounce, fullyIntoViewOrBorder) {\n    \n    try {\n      \n      const {top, bottom} = el.getBoundingClientRect();\n      // console.log('utils.factory->isElementIntoViewport(): getBoundingClientRect()', top, bottom)\n      \n      // const isTopBorderAboveBottomEdge = bottom >= (bounce ? (bounce * (-1)) : 0);\n      \n      // is widget bottom border below viewport top edge?\n      const isBottomBorderAboveTopEdge = bottom >= (bounce ? (bounce * (-1)) : 0);\n      \n      // is widget top border below viewport top edge?\n      const isTopBorderBelowTopEdge = top >= (bounce ? (bounce * (-1)) : 0);\n      \n      // is widget top border above viewport bottom edge?\n      const isTopBorderAboveBottomEdge = top <= (global.innerHeight + (bounce || 0));\n      \n      // is widget bottom border above viewport bottom edge?\n      const isBottomBorderAboveBottomEdge = bottom <= (global.innerHeight + (bounce || 0));\n      \n      // console.log('utils.factory->isElementIntoViewport(): boundingRect', [top, bottom], global.innerHeight, height, isBottomBorderAboveTopEdge, isTopBorderAboveBottomEdge, isBottomBorderAboveBottomEdge, isTopBorderBelowTopEdge);\n      \n      if (fullyIntoViewOrBorder) {\n        \n        if (fullyIntoViewOrBorder === true) {\n          \n          // is the widget fully into view port\n          return !!(isBottomBorderAboveBottomEdge && isTopBorderBelowTopEdge);\n          \n        }\n        else if (fullyIntoViewOrBorder === 'bottom') {\n          \n          // is the widget fully into view port\n          return !!isBottomBorderAboveBottomEdge;\n          \n        }\n        else if (fullyIntoViewOrBorder === 'top') {\n          \n          // is the widget fully into view port\n          return !!isTopBorderBelowTopEdge;\n          \n        }\n        \n      }\n      else {\n        \n        // is any piece of the widget into view port\n        return !!(isBottomBorderAboveTopEdge && isTopBorderAboveBottomEdge);\n        \n      }\n      \n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to generate a GUID (string)\n   */\n  generateGUID() {\n    try {\n      let d = new Date().getTime();\n      \n      if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n        d += performance.now();\n      }\n      \n      let newGuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        const r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);\n      });\n      \n      return 'GC-' + newGuid;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to return a string escape special character\n   * @param str\n   */\n  getEscapedName(str) {\n    return str\n      .replace(/\\s|_/g, '-')\n      .replace(/\\*|\\//g, '')\n      .replace(/([A-Z]*)/g, function (value) {\n        \n        if (value) {\n          if (value.length > 1) {\n            value = value + '-';\n          }\n        }\n        \n        return value.toLowerCase();\n      });\n  }\n  \n  /**\n   * Method to get the params from a full URL\n   */\n  getUrlHostDomain(url) {\n    \n    try {\n      \n      url += '/';\n      console.log('UtilsFactory->getAjax(): url', url);\n      \n      const host = url.match(/(https?:\\/\\/)?(www.)?([0-9A-z.\\-_+]*\\.([A-z]{2,3}))/i);\n      console.log('UtilsFactory->getAjax(): host', host);\n      \n      return host[3];\n      \n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to inject a script lib into <head> tag\n   */\n  async injectTag(url, type, persistResponseOrAsType, timeout) {\n    return new Promise((resolve, reject) => {\n      \n      console.log('utils.factory->injectTag(): url', url, type, persistResponseOrAsType);\n      \n      try {\n        \n        if (!type) {\n          type = 'script';\n        }\n        \n        if (['script', 'link'].indexOf(type) === -1) {\n          reject(`The type '${type}' is not valid.`);\n          throw new Error(`The type '${type}' is not valid.`);\n        }\n        \n        if (!url || typeof url !== 'string') {\n          reject(`The URL '${url}' is not valid.`);\n          throw new Error(`The URL '${url}' is not valid.`);\n        }\n        \n        const tagId = global.btoa(url);\n        let tagEl = null;\n        \n        // Debug.log('InjectTag', tagId, document.getElementById(tagId))\n        \n        if (!document.getElementById(tagId)) {\n          tagEl = document.createElement(type);\n          tagEl.id = tagId;\n          \n          if (type === 'script') {\n            tagEl.src = url;\n          }\n          else if (type === 'link') {\n            tagEl.href = url;\n            tagEl.rel = 'stylesheet';\n            \n            if (typeof persistResponseOrAsType === 'string') {\n              tagEl.as = persistResponseOrAsType;\n            }\n          }\n          \n          document.getElementsByTagName('head')[0].appendChild(tagEl);\n          \n        }\n        \n        if (type === 'script' && typeof persistResponse === 'function') {\n          \n          let countTimeout = 0;\n          \n          const interval = setInterval(() => {\n            \n            const persistValidation = persistResponse();\n            \n            console.log('UtilsFactory->injectTag(): url', countTimeout, url, persistValidation);\n            \n            if (persistValidation) {\n              clearInterval(interval);\n              resolve(persistValidation);\n            }\n            else if (countTimeout > (timeout || 5000)) {\n              clearInterval(interval);\n              reject(new Error(`The persistResponse() has timed out for ${url}.`));\n            }\n            \n            countTimeout += 10;\n            \n          }, 10);\n        }\n        else if (type === 'script' && tagEl && !tagEl.onload) {\n          tagEl.onload = () => {\n            resolve();\n          };\n        }\n        else {\n          resolve();\n        }\n      }\n      catch (e) {\n        reject(e);\n      }\n      \n    });\n  }\n  \n  /**\n   * Method to check is the user is using a mobile browser\n   */\n  isMobile() {\n    try {\n      if (this.isBrowser()) {\n        return !!(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(global.navigator.userAgent || global.navigator.vendor || global.opera) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test((global.navigator.userAgent || global.navigator.vendor || global.opera).substr(0, 4)));\n      }\n      else {\n        return false;\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to execute a GET ajax call\n   */\n  async getAjax(options) {\n    \n    _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): options', options);\n    \n    try {\n      if (!options.url) {\n        throw new Error('The URL must be provided.');\n      }\n      \n      let cacheData = null;\n      \n      if (!options.fromCache || options.cacheBuster) {\n        \n        const cb = Date.now(); // new Date().toJSON().slice(0, 13).replace(/[T-]/g, '');\n        \n        if (options.data) {\n          options.data.cb = cb;\n        }\n        else {\n          options.data = {\n            cb: cb\n          };\n        }\n      }\n      \n      // Debug.log('UtilsFactory->getAjax(): options.data', options.data)\n      const url = options.url + (options.data ? '?' + this.serializeObject(options.data) : '');\n      \n      _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): this.serializeObject(options.data)', this.serializeObject(options.data));\n      _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): url 1', url);\n      \n      // cache key\n      const cacheKey = options.cacheKey || 'gc:' + url;\n      \n      if (options.fromCache !== false) {\n        if (this.storageLocal[cacheKey]) {\n          cacheData = this.storageLocal[cacheKey];\n        }\n        else if (global.localStorage) {\n          // get the response from localStorage\n          cacheData = global.localStorage.getItem(cacheKey);\n          cacheData = JSON.parse(cacheData);\n        }\n      }\n      \n      _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): url 2', url, !!cacheData);\n      // Debug.log('UtilsFactory->getAjax(): cacheData', cacheData)\n      \n      // get from cache? is there any cache and hasn't it expired?\n      if (cacheData) {\n        \n        _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): Date.now()', Date.now() - cacheData.created_at, (5000 * 60));\n        \n        // if the cache expired?\n        if ((new Date().getTime() - cacheData.created_at) > (5000 * 60)) {\n          \n          if (this.storageLocal[cacheKey]) {\n            delete this.storageLocal[cacheKey];\n          }\n          \n          // if the cache has expired, remove it\n          global.localStorage.removeItem(cacheKey);\n          \n        }\n        \n        // resolve the promise with the cache data\n        return cacheData.data;\n        \n      }\n      else {\n        \n        _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('UtilsFactory->getAjax(): url 3', url);\n        \n        let data = null;\n        \n        try {\n          const response = await axios__WEBPACK_IMPORTED_MODULE_0___default.a.get(url);\n          data = response.data;\n        }\n        catch (e) {\n          e.url = url;\n          throw new Error(e);\n        }\n        \n        // Debug.log('UtilsFactory->getAjax(): data', data)\n        \n        if (!data) {\n          throw new Error(`The response data is empty for ${url}`);\n        }\n        \n        // is the type JSON?\n        if (options.type === 'json') {\n          if (!data || data.errorMessage || data.error) {\n            throw new Error(data || 'The was a error while try to make the ajax call.');\n          }\n        }\n        \n        const contentData = {\n          \n          // setting a time for check the cache expiration later\n          created_at: new Date().getTime(),\n          \n          // cache content\n          data: data\n          \n        };\n        \n        // save data into localStorage?\n        if (options.fromCache !== false && global.localStorage) {\n          \n          try {\n            // save the response into localStorage\n            global.localStorage.setItem(cacheKey, JSON.stringify(contentData));\n          }\n          catch (e) {\n            _debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].warn(`${e.message} Saving it to Memory Cache instead. This will last until the user refreshes the page.`);\n            this.storageLocal[cacheKey] = contentData;\n          }\n          \n        }\n        \n        return contentData.data;\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (new UtilsFactory());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../var/task/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/base.model.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BaseModel; });\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factories/utils.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js\");\n/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n\n// factories dependencies\n\n\n\nclass BaseModel {\n\n  constructor (model, removeIfNull) {\n    this.init()\n    this.fill(model, removeIfNull)\n  }\n\n  fill (model, removeIfNull) {\n    // Debug.log('BaseModel->fill(): model', model)\n    try {\n      if (model) {\n        for (let i in this) {\n          // Debug.log('BaseModel->fill(): i', i, model[i], this[i])\n          if (i in model) {\n            if (this[i] instanceof BaseModel) {\n              this[i].fill(model[i])\n            }\n            else {\n              // Debug.log('BaseModel->fill(): i', i, model[i], this[i])\n              this[i] = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseValue(model[i])\n            }\n          }\n\n          if (removeIfNull && this[i] === null) {\n            delete this[i]\n          }\n        }\n      }\n\n      if ('onFill' in this) {\n        this.onFill(model)\n      }\n    }\n    catch (e) {\n      throw new Error(e)\n    }\n  }\n\n}\n\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/base.model.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/info.model.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InfoModel; });\n/* harmony import */ var _base_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.model */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/base.model.js");\n/* harmony import */ var _publisher_site_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./publisher-site.model */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/publisher-site.model.js");\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/utils.factory */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js");\n\n\n\n\n/**\n * Info Model Class\n */\nclass InfoModel extends _base_model__WEBPACK_IMPORTED_MODULE_0__["default"] {\n  \n  init() {\n    \n    this.publisher_site = new _publisher_site_model__WEBPACK_IMPORTED_MODULE_1__["default"]()\n    \n    this.active = true;\n    this.widget_version = 2;\n    this.widget_lazy_loading = false;\n    \n    this.gcid = null;\n    this.disable_widget = false;\n    this.disable_ads = null;\n    this.utm_source = null;\n    this.gdpr = null;\n    this.enable_cmp = true;\n    this.googlefc = true;\n    this.force_widget_full_width = null;\n    this.force_renew_cache = null;\n    this.cache_buster = null;\n    \n    this.widget_target_enabled = null;\n    this.widget_target_type = null;\n    this.widget_target_name = null;\n    this.widget_target_value = null;\n    this.widget_start_at = null;\n    this.widget_end_at = null;\n    this.carousel_auto_rotation = null;\n    this.enable_single_ad_section = null;\n    this.enable_top_single_ad_section = null;\n    this.enable_top_single_ad_section_mobile = null;\n    this.ads_delay = null;\n    this.widget_delay = null;\n    this.widget_theme = null;\n    this.networks_order = null;\n    this.get_from_ssr = false;\n    this.enable_ads_removal = null;\n    \n    this.family_group_profile = null;\n    \n    this.enable_bottom_ad = null;\n    this.enable_bottom_ad_mobile = null;\n    \n    this.bottom_ad_refresh_time = null;\n    this.nofill_ad_refresh_time = null;\n    \n    this.disable_auto_install = null;\n    \n    this.enable_utm_source_report = null;\n    \n    this.show_advertisement_label = null;\n    \n    this.negative_targets = [];\n    this.negative_tags = null;\n    \n  }\n  \n  onFill() {\n    \n    if (this.disable_ads) {\n      this.enable_single_ad_section = false;\n      this.enable_top_single_ad_section = false;\n      this.enable_top_single_ad_section_mobile = false;\n    }\n    \n    if (this.enable_single_ad_section || this.enable_top_single_ad_section) {\n      this.show_advertisement_label = false;\n    }\n    \n    if (this.enable_top_single_ad_section_mobile && _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__["default"].isMobile()) {\n      this.show_advertisement_label = false;\n    }\n    \n  }\n  \n}\n\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/info.model.js?')},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/publisher-site.model.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PublisherSite; });\n/* harmony import */ var _base_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.model */ "../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/base.model.js");\n\n\n/**\n * PublisherSite Model Class\n */\nclass PublisherSite extends _base_model__WEBPACK_IMPORTED_MODULE_0__["default"] {\n\n  init (model) {\n\n    this.id = null\n    this.host = null\n    this.ad_unit_name = null\n    \n  }\n\n}\n\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/publisher-site.model.js?')},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/widget.model.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WidgetModel; });\n/* harmony import */ var _bugsnag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bugsnag/js */ \"./node_modules/@bugsnag/js/browser/notifier.js\");\n/* harmony import */ var _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_bugsnag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _base_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base.model */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/base.model.js\");\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/utils.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js\");\n\n\n\n// factories dependencies\n\n\n/**\n * Info Model Class\n */\nclass WidgetModel extends _base_model__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  \n  init() {\n    \n    this.widget_version = 2;\n    this.widget_lazy_loading = false;\n    \n    this.widget_core = null;\n    this.gcid = null;\n    this.widget_id = null;\n    this.parentContainer = null;\n    this.container = null;\n    this.widget_index = null;\n    this.utm_source = null;\n    this.family_group_profile = null;\n    \n    this.is_requesting = false;\n    this.has_rendered = false;\n    this.show_advertisement_label = true;\n    this.enable_single_ad_section = null;\n    \n    this.is_into_viewport = false;\n    this.is_close_to_viewport = false;\n    this.is_fully_into_viewport = false;\n    this.is_bottom_border_above_bottom_edge = true;\n    \n    this.prev_widget_model = null;\n    this.next_widget_model = null;\n    this.has_just_removed = false;\n    this.is_removing = false;\n    this.force_widget_full_width = null;\n    \n    this.publisher_info_cb = null;\n    // this.force_renew_cache = null;\n    this.enable_cache = false;\n    this.cache_buster = null;\n    this.widget_url = null;\n    this.disable_ads = null;\n    this.widget_width = 500;\n    this.widget_theme = null;\n    this.networks_order = null;\n    this.carousel_auto_rotation = null;\n    this.ads_delay = null;\n    this.enable_ads_removal = null;\n    \n    this.widgetFrame = null;\n    \n    this.enable_bottom_ad = null;\n    this.enable_bottom_ad_mobile = null;\n    this.bottom_ad_refresh_time = null;\n    this.nofill_ad_refresh_time = null;\n  }\n  \n  /**\n   * Method to be trigger as soon as the constructor has\n   * been created: \"new WidgetModel()\"\n   */\n  onFill() {\n    \n    // console.log('WidgetModel->onFill(): this', this);\n    \n    try {\n      if (this.container) {\n        \n        // this.widget_id = UtilsFactory.generateGUID()\n        \n        // this.container.setAttribute('widget-id', this.widget_id)\n        this.widget_width = this.container.offsetWidth;\n        \n        if (this.widget_version === 3) {\n          // this.widget_url += '/standard';\n        }\n        \n        if (_factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isElementIntoViewport(this.container)) {\n          this.is_into_viewport = true;\n          this.container.setAttribute('into-viewport', 'true');\n        }\n        else {\n          this.is_into_viewport = false;\n          this.container.removeAttribute('into-viewport');\n        }\n        \n        if (this.container.className.match(/\\s?gcwp-carousel\\s/g) === null) {\n          this.container.className = `${this.container.className} gcwp-carousel `;\n        }\n        \n        if (this.container.className.match(/\\s?gcwp-carousel-auto-install\\s/g) === null) {\n          this.container.className = `${this.container.className} gcwp-carousel-auto-install `;\n        }\n        \n        if (this.enable_single_ad_section && this.container.className.match(/\\s?gcwp-carousel-single-ad-section\\s/g) === null) {\n          this.container.className = `${this.container.className} gcwp-carousel-single-ad-section `;\n        }\n        \n        if (this.force_widget_full_width && this.container.className.match(/\\s?gcwp-carousel-force-full-width\\s/g) === null) {\n          this.container.className = `${this.container.className} gcwp-carousel-force-full-width `;\n        }\n        \n        if (this.widget_lazy_loading) {\n          this.watchIfIntoViewport();\n        }\n        \n      }\n      else {\n        // throw new Error(`The 'id' and 'container' must be provided.`)\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  changeIframeHeight(innerHeight) {\n    try {\n      // console.log('WidgetModel->changeIframeHeight(): this.widgetFrame', innerHeight);\n      if (this.widgetFrame) {\n        this.widgetFrame.style.height = `${innerHeight}px`;\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to add a css class that will change the height of the this.container\n   */\n  expandWidgetHeight(isDoubleBottomAd) {\n    \n    console.log('WidgetModel->expandWidgetHeight() isDoubleBottomAd', isDoubleBottomAd);\n    \n    try {\n      if (this.container.className.match(/\\s?gcwp-carousel-expanded\\s/g) === null) {\n        this.container.className = `${this.container.className} gcwp-carousel-expanded `;\n      }\n      \n      if (isDoubleBottomAd && this.container.className.match(/\\s?gcwp-carousel-expanded-extra\\s/g) === null) {\n        this.container.className = `${this.container.className} gcwp-carousel-expanded-extra `;\n      }\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to remove the css class that changed the height of the this.container\n   */\n  removeExpandWidgetHeight() {\n    \n    console.log('WidgetModel->removeExpandWidgetHeight()');\n    \n    try {\n      this.container.className = this.container.className.replace('gcwp-carousel-expanded', '');\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to destroy widget model and remove the widget element within the DOM\n   */\n  destroyWidget() {\n    console.log('WidgetModel->destroyWidget() this', this);\n    try {\n      \n      if (this.parentContainer) {\n        console.log('WidgetModel->destroyWidget() this.parentContainer', this.parentContainer);\n        this.parentContainer.removeAttribute('gc-widget-has-installed');\n      }\n      \n      if (this.container) {\n        console.log('WidgetModel->destroyWidget() this.container', this.container);\n        this.container.remove();\n      }\n      \n      for (let i in this) {\n        this[i] = null;\n      }\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to cancel the removal process (timeout)\n   */\n  cancelAutoRemoval() {\n    try {\n      \n      if (this.removalTimeout && this.has_rendered) {\n        \n        // console.log('WidgetModel->cancelAutoRemoval(): AUTO_REMOVE this', this.has_rendered)\n        \n        this.container.removeAttribute('auto-remove');\n        clearTimeout(this.removalTimeout);\n        this.is_removing = false;\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * method to trigger the remove process\n   */\n  autoRemoveWidget() {\n    \n    try {\n      if (this.has_rendered && this.is_removing === false) {\n        this.is_removing = true;\n        \n        console.log('WidgetModel->autoRemoveWidget(): AUTO_REMOVE this', this.has_rendered);\n        \n        this.container.setAttribute('auto-remove', 'true');\n        \n        if (this.removalTimeout) {\n          clearTimeout(this.removalTimeout);\n        }\n        \n        this.removalTimeout = setTimeout(() => {\n          \n          console.log('WidgetModel->autoRemoveWidget(): AUTO_REMOVE setTimeout()');\n          this.container.style.height = `${this.container.offsetHeight}px`;\n          \n          setTimeout(() => {\n            this.has_rendered = false;\n            this.has_just_removed = true;\n            this.container.innerHTML = '';\n            this.container.removeAttribute('auto-remove');\n            this.container.removeAttribute('rendered');\n            \n            this.afterRemovalTimeout = setTimeout(() => {\n              this.has_just_removed = false;\n              this.is_removing = false;\n            }, 300);\n            \n            if (!this.widget_lazy_loading && this.intoViewportInterval) {\n              this.container.removeAttribute('into-viewport');\n              clearInterval(this.intoViewportInterval);\n            }\n          }, 10);\n          \n        }, 10000);\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to watch if the element got into view port\n   */\n  watchIfIntoViewport() {\n    \n    // console.log('WidgetModel->watchIfIntoViewport(): this', this.is_into_viewport, this);\n    \n    try {\n      \n      if (this.intoViewportInterval) {\n        clearInterval(this.intoViewportInterval);\n      }\n      \n      this.intoViewportInterval = setInterval(() => {\n        \n        if (!this.container) {\n          clearInterval(this.intoViewportInterval);\n          return false;\n        }\n        \n        this.is_close_to_viewport = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isElementIntoViewport(this.container, window.innerHeight);\n        this.is_into_viewport = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isElementIntoViewport(this.container);\n        this.is_fully_into_viewport = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isElementIntoViewport(this.container, null, true);\n        this.is_bottom_border_above_bottom_edge = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isElementIntoViewport(this.container, null, 'bottom');\n        \n        // console.log('WidgetModel->watchIfIntoViewport(): this.is_close_to_viewport', this.is_close_to_viewport, this.is_into_viewport, this.is_fully_into_viewport, this.is_bottom_border_above_bottom_edge);\n        \n        // is close to viewport?\n        if (this.is_close_to_viewport) {\n          this.container.setAttribute('close-to-viewport', 'true');\n          \n          if (this.widget_lazy_loading) {\n            this.renderWidget();\n          }\n        }\n        else {\n          if (this.widget_lazy_loading) {\n            this.autoRemoveWidget();\n          }\n          this.container.removeAttribute('close-to-viewport');\n        }\n        \n        // is into viewport?\n        if (this.is_into_viewport) {\n          this.container.setAttribute('into-viewport', 'true');\n        }\n        else {\n          this.container.removeAttribute('into-viewport');\n        }\n        \n        // is fully into viewport?\n        if (this.is_fully_into_viewport) {\n          this.container.setAttribute('fully-into-viewport', 'true');\n        }\n        else {\n          this.container.removeAttribute('fully-into-viewport');\n        }\n        \n      }, 100);\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to return if widget is into viewport or not\n   * @returns {boolean}\n   */\n  isIntoViewport() {\n    try {\n      return this.is_into_viewport;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to inject and render the widget index.html\n   */\n  async renderWidget(isSSR) {\n    \n    // console.log('WidgetModel->renderWidget(): has_just_removed', this.has_just_removed, this.container);\n    \n    try {\n      \n      this.cancelAutoRemoval();\n      \n      if (this.has_just_removed !== true && !this.has_rendered && this.is_requesting !== true) {\n  \n        _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.addMetadata('widget-model', this);\n        \n        console.log('WidgetModel->renderWidget(): this.widget_url', this.widget_url);\n        \n        this.is_requesting = true;\n        \n        const getData = {\n          standard: true,\n          is_standard_widget: true,\n          gcid: this.gcid,\n          disable_ads: this.disable_ads,\n          widget_width: this.widget_width,\n          carousel_auto_rotation: this.carousel_auto_rotation,\n          ads_delay: this.ads_delay,\n          enable_ads_removal: this.enable_ads_removal,\n          widget_theme: this.widget_theme,\n          bottom_ad_refresh_time: this.bottom_ad_refresh_time,\n          nofill_ad_refresh_time: this.nofill_ad_refresh_time,\n          networks_order: this.networks_order,\n          enable_bottom_ad: this.enable_bottom_ad,\n          enable_bottom_ad_mobile: this.enable_bottom_ad_mobile,\n          utm_source: this.utm_source,\n          publisher_info_cb: this.publisher_info_cb,\n          widget_index: this.widget_index,\n          build_version: this.cache_buster,\n          // force_renew_cache: this.force_renew_cache ? Date.now() : null,\n          family_group_profile: this.family_group_profile\n        };\n        \n        const enable_cache = isSSR ? false : this.enable_cache;\n  \n        console.log('WidgetModel->renderWidget(): this.widget_url', this.widget_url);\n        console.log('WidgetModel->renderWidget(): getData', getData);\n        console.log('WidgetModel->renderWidget(): enable_cache', enable_cache);\n        console.log('WidgetModel->renderWidget(): isSSR', isSSR);\n        \n        const ajaxConfig = {\n          url: this.widget_url,\n          data: getData,\n          fromCache: enable_cache,\n          cacheBuster: isSSR\n        };\n  \n        _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.addMetadata('widget-ajax-config', ajaxConfig);\n  \n        let widgetIndexContent = await _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getAjax(ajaxConfig);\n        \n        this.is_requesting = false;\n        \n        if (widgetIndexContent.indexOf('<base') > -1) {\n          widgetIndexContent = widgetIndexContent.replace(/<base\\shref=\\\"([A-z0-9/:_.-]*)\\\"\\s?>/, `<base href=\"${this.widget_url}\">`);\n        }\n        else {\n          widgetIndexContent = widgetIndexContent.replace(/<\\/title>/, `</title><base href=\"${this.widget_url}\">`);\n        }\n  \n        _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.clearMetadata('widget-model');\n        _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.clearMetadata('widget-ajax-config');\n        \n        if (this.container && this.widget_id) {\n          await this.injectIframe(widgetIndexContent);\n          this.watchIfIntoViewport();\n          this.container.setAttribute('rendered', 'true');\n        }\n        else {\n          return widgetIndexContent;\n        }\n        \n      }\n      \n      return true;\n      \n    }\n    catch (e) {\n      console.error('WidgetModel->renderWidget(): ERROR', e);\n  \n      _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.notify(e);\n      _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.clearMetadata('widget-model');\n      _bugsnag_js__WEBPACK_IMPORTED_MODULE_0___default.a.clearMetadata('widget-ajax-config');\n      \n      throw e;\n    }\n  }\n  \n  /**\n   * Method to create the IFRAME element and inject it into the widget container\n   */\n  async injectIframe(widgetIndexContent) {\n    \n    console.log('WidgetModel->injectIframe(): this', this);\n    \n    return new Promise((resolve, reject) => {\n      try {\n        if (!this.container.querySelector('iframe')) {\n          \n          this.widgetFrame = document.createElement('iframe');\n          \n          // Set up HTML properties and styles for the IFRAME\n          const frameProps = {\n            className: 'gcwp-iframe',\n            height: 0,\n            marginWidth: 0,\n            frameBorder: 0,\n            maxHeight: 0,\n            scrolling: 'no',\n            width: '100%',\n            sandbox: 'allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation-by-user-activation' // Without \"allow-top-navigation\" the child iframes cannot force-redirect\n          };\n          \n          for (let i in frameProps) {\n            this.widgetFrame[i] = frameProps[i];\n          }\n          \n          this.has_rendered = true;\n          \n          // global.console.timeEnd('GC: Time WIDGET is injected')\n          this.container.appendChild(this.widgetFrame);\n          \n          console.log('WidgetModel->injectIframe(): widgetFrame.contentWindow', this.widgetFrame.contentWindow.document);\n          \n          this.widgetFrame.onload = () => {\n            console.log('WidgetModel->injectIframe(): onload', this);\n            \n            this.widgetFrame.contentWindow.WidgetModel = this;\n            this.widgetFrame.contentWindow.GC = this.widget_core;\n            \n            setTimeout(() => {\n              this.container.style.height = 'auto';\n              \n              console.log('WidgetModel->injectIframe(): this.show_advertisement_label', this.show_advertisement_label);\n              \n              if (this.show_advertisement_label !== false && !this.container.querySelector('gcwp-advertisement-label') && !this.enable_single_ad_section) {\n                const advertisementLabel = document.createElement('div');\n                advertisementLabel.className = 'gcwp-advertisement-label';\n                advertisementLabel.innerHTML = '<span>Advertisement</span>';\n                this.container.appendChild(advertisementLabel);\n                \n                // Insert the new node before the reference node\n                this.container.insertBefore(advertisementLabel, this.container.firstChild);\n              }\n              \n            }, 100);\n            \n            /*\n             console.log('forced', 'WidgetModel->injectIframe(): match', this.container.className.match(/\\s?gcwp-carousel-auto-install\\s/g))\n             \n             if (this.container.className.match(/\\s?gcwp-carousel-auto-install\\s/g) === null) {\n             this.container.className = `${this.container.className} gcwp-carousel-auto-install `\n             }\n             */\n            \n          };\n          \n          this.widgetFrame.contentWindow.document.open();\n          this.widgetFrame.contentWindow.document.write(widgetIndexContent);\n          this.widgetFrame.contentWindow.document.close();\n          \n          this.widgetFrame.contentWindow.WidgetModel = this;\n          this.widgetFrame.contentWindow.GC = this.widget_core;\n          \n          resolve(this.widgetFrame);\n        }\n      }\n      catch (e) {\n        console.error(e);\n        reject(e);\n      }\n    });\n  }\n  \n}\n\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/widget.model.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/cmp.module.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CmpModule; });\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factories/utils.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js\");\n/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n// factories dependencies\n\n\n\nclass CmpModule {\n  \n  constructor() {\n  }\n  \n  /**\n   * Method to show the CMP message\n   */\n  showCmpMessage() {\n    try {\n      window.googlefc.showRevocationMessage();\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to hide the CMP message\n   */\n  hideCmpMessage() {\n    try {\n      const fcConsentRootEl = document.querySelector('.fc-consent-root, .fc-ccpa-root');\n      \n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModules->hideCmpMessage() fcConsentRootEl', fcConsentRootEl);\n      \n      if (fcConsentRootEl) {\n        \n        const fcConsentRootClassName = fcConsentRootEl.className.split(' ');\n        \n        fcConsentRootClassName.splice(fcConsentRootClassName.indexOf('gc-fc-consent-opened'), 1);\n        fcConsentRootEl.className = fcConsentRootClassName.join(' ');\n        \n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to load the CMP JS lib\n   * @returns {Promise<void>}\n   */\n  async loadCmpLib() {\n    \n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->loadCmpLib()');\n    \n    try {\n      await _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].injectTag('https://cdn.gotchosen.com/google/funding-choices.js', 'script', () => {\n        return window.googlefc && window.__tcfapi;\n      }, 10000);\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to initiate the CMP process\n   * @param options\n   * @returns {Promise<void>}\n   */\n  async startCmp(options) {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): options', options);\n    \n    if (typeof options !== 'object') {\n      options = {};\n    }\n    \n    let allowLoadLibFC = false;\n    \n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): global.GC_CLIENT_SETTINGS.googlefc', global.GC_CLIENT_SETTINGS.googlefc);\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): window.__tcfapi', window.__tcfapi);\n    \n    /*if (options.gdpr !== false && global.GC_CLIENT_SETTINGS.googlefc !== false) {\n     if (global.GC_CLIENT_SETTINGS.googlefc === 'LOAD_IF_TCF_NONEXISTENT') {\n     if (!window.__tcfapi && !window.googlefc) {\n     allowLoadLibFC = true;\n     }\n     }\n     else if (global.GC_CLIENT_SETTINGS.googlefc !== false) {\n     if (!window.googlefc) {\n     allowLoadLibFC = true;\n     }\n     }\n     }*/\n    \n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): allowLoadLibFC', allowLoadLibFC);\n    \n    if (allowLoadLibFC) {\n      \n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): ', window.__tcfapi, window.googlefc);\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): global.GC_CLIENT_SETTINGS', global.GC_CLIENT_SETTINGS);\n      \n      // Make sure that the properties exist on the window.\n      window.googlefc = window.googlefc || {};\n      window.googlefc.callbackQueue = window.googlefc.callbackQueue || [];\n      \n      // To guarantee functionality, this must go before the FC tag on the page.\n      googlefc.controlledMessagingFunction = (message) => {\n        \n        let showGdprModal = !window.__tcfapi && global.GC_CLIENT_SETTINGS.enable_cmp !== false;\n        _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): controlledMessagingFunction(): proceed', !showGdprModal);\n        // false = NO show\n        // true  =    show\n        \n        message.proceed(false); // if does not have Tcfapi, show our CMP consentiment modal\n      };\n      \n      await this.loadCmpLib();\n      \n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('CmpModule->startCmp(): FINISHED', window.__tcfapi, window.googlefc);\n      \n    }\n    \n  }\n  \n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../var/task/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/cmp.module.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/events.module.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EventsModule; });\n/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factories/debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n// factories dependencies\n\n\nclass EventsModule {\n\n  constructor () {\n    // Debug.log('EventsModules->constructor()')\n    this.callbackFunctions = {}\n  }\n\n  /**\n   * Private method to be trigger when a action has happened\n   */\n  triggerCallbacks (nameSpace, params) {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].log('EventsModules->triggerCallbacks(): nameSpace', nameSpace, params)\n    try {\n      if (\n        this.callbackFunctions &&\n        this.callbackFunctions[nameSpace] &&\n        this.callbackFunctions[nameSpace].length\n      ) {\n\n        for (let i in this.callbackFunctions[nameSpace]) {\n          if (typeof this.callbackFunctions[nameSpace][i] === 'function') {\n            this.callbackFunctions[nameSpace][i](params)\n          }\n        }\n\n        delete this.callbackFunctions[nameSpace]\n\n      }\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to register a callback function to be triggered later\n   */\n  registerCallbacks (nameSpace, callback) {\n\n    try {\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].log('EventsModules->registerCallbacks(): nameSpace', nameSpace)\n\n      if (!this.callbackFunctions[nameSpace]) {\n        this.callbackFunctions[nameSpace] = []\n      }\n\n      if (typeof callback === 'function' && this.callbackFunctions[nameSpace].indexOf(callback) === -1) {\n        this.callbackFunctions[nameSpace].push(callback)\n      }\n\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].log('EventsModules->registerCallbacks(): this.callbackFunctions', this.callbackFunctions)\n\n      // Debug.log('EventsModules->registerCallbacks(): this.callbackFunctions', this.callbackFunctions)\n    }\n    catch (e) {\n      throw e\n    }\n\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselLoaded (callback) {\n\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].log('EventsModules->onCarouselLoaded(): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-loaded', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselInitialization (callback) {\n\n    // Debug.log('EventsModules->onCarouselInitialization (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-initialization', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselAdRequest (callback) {\n\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].log('EventsModules->onCarouselAdRequest (): callback', this)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-ad-request', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselBidRequest (callback) {\n\n    // Debug.log('EventsModules->onCarouselBidRequest (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-bid-request', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselAdLiked (callback) {\n\n    // Debug.log('EventsModules->onCarouselAdLiked (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-ad-liked', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselPostClicked (callback) {\n\n    // Debug.log('EventsModules->onCarouselPostClicked (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-post-clicked', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselPostPlayVideo (callback) {\n\n    // Debug.log('EventsModules->onCarouselPostPlayVideo (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-post-play-video', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselPostLiked (callback) {\n\n    // Debug.log('EventsModules->onCarouselPostLiked (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-post-liked', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselPostShared (callback) {\n\n    // Debug.log('EventsModules->onCarouselPostShared (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-post-shared', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselSlideNext (callback) {\n\n    // Debug.log('EventsModules->onCarouselSlideNext (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-slide-next', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to watch for a specific trigger has fired\n   */\n  onCarouselSlideBack (callback) {\n\n    // Debug.log('EventsModules->onCarouselSlideBack (): callback', callback)\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new Error(`You must provide a Function as \"callback\".`)\n      }\n      this.registerCallbacks('widget-carousel-slide-back', callback)\n    }\n    catch (e) {\n      throw e\n    }\n  }\n\n  /**\n   * Method to trigger the ADs Enable (set flag\n   * for internal control)\n   */\n  enableAds () {\n    this.hasTriggeredEnableAds = true\n  }\n}\n\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/events.module.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/negative-targeting.module.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return NegativeTargetingModule; });\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../factories/utils.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js\");\n/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n// import {SETTINGS} from '../core.service'\n\n// factories dependencies\n\n\n\nclass NegativeTargetingModule {\n  \n  constructor() {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->constructor()');\n  }\n  \n  /**\n   * Method to return the count of days between 2 dates\n   */\n  diffDates(date1, date2) {\n    try {\n      \n      const dt1 = new Date(date1);\n      const dt2 = new Date(date2);\n      \n      return Math.floor((\n                          Date.UTC(dt2.getFullYear(), dt2.getMonth(), dt2.getDate()) - Date.UTC(dt1.getFullYear(), dt1.getMonth(), dt1.getDate())\n                        ) / (\n                          1000 * 60 * 60 * 24\n                        ));\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to return a converted string date\n   */\n  stringToDate(date) {\n    try {\n      let finalDate = date;\n      \n      if (date.indexOf('T') > 0) {\n        finalDate = date.split('T')[0];\n      }\n      \n      finalDate = finalDate.split('-');\n      \n      return new Date(finalDate[0], finalDate[1] - 1, finalDate[2]);\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to validate if the dates startAt/endAt is valid\n   */\n  isBlockedByDates(startAt, endAt) {\n    // Debug.log('NegativeTargetingModule->isBlockedByDates(): startAt/endAt', startAt, endAt)\n    \n    try {\n      const today = new Date();\n      \n      let diffStartDate = null;\n      let diffEndDate = null;\n      \n      startAt = this.stringToDate(startAt);\n      endAt = this.stringToDate(endAt);\n      \n      if (startAt && endAt) {\n        diffStartDate = this.diffDates(today, startAt);\n        diffEndDate = this.diffDates(today, endAt);\n      }\n      \n      // Debug.log('NegativeTargetingModule->isBlockedByDates(): diffStartDate', diffStartDate, startAt)\n      // Debug.log('NegativeTargetingModule->isBlockedByDates(): diffEndDate', diffEndDate, endAt)\n      \n      if (startAt && endAt) {\n        if (diffStartDate <= 0 && diffEndDate >= 0) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n      else {\n        return true;\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to validate the MetaTag\n   */\n  isBlockedByMetatag(widgetTargetName, widgetTargetValue) {\n    // Debug.log('NegativeTargetingModule->validateMetatag()')\n    \n    try {\n      // Debug.log('NegativeTargetingModule->validateMetatag(): widgetTargetName', widgetTargetName)\n      \n      const metatagElement = document.querySelector(`meta[name=\"${widgetTargetName}\"]`);\n      let isBlockedByMetatag = !!metatagElement;\n      \n      // Debug.log('NegativeTargetingModule->validateMetatag(): metatagElement', metatagElement)\n      // Debug.log('NegativeTargetingModule->validateMetatag(): isBlockedByMetatag', isBlockedByMetatag)\n      \n      if (widgetTargetValue && metatagElement) {\n        isBlockedByMetatag = metatagElement.getAttribute('content') === widgetTargetValue;\n        // Debug.log('NegativeTargetingModule->validateMetatag(): widgetTargetValue',\n        // metatagElement.getAttribute('content'), widgetTargetValue)\n      }\n      \n      // Debug.log('NegativeTargetingModule->validateMetatag(): isBlockedByMetatag', isBlockedByMetatag)\n      \n      return isBlockedByMetatag;\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to validate the MetaTag\n   */\n  isBlockedByJavaScriptTag(widgetTargetName, widgetTargetValue) {\n    // Debug.log('NegativeTargetingModule->isBlockedByJavaScriptTag()')\n    \n    try {\n      // Debug.log('NegativeTargetingModule->isBlockedByJavaScriptTag(): widgetTargetName', widgetTargetName)\n      // Debug.log('NegativeTargetingModule->isBlockedByJavaScriptTag(): widgetTargetValue', widgetTargetValue)\n      \n      if (widgetTargetValue !== null) {\n        const parsedValue = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseValue(widgetTargetValue);\n        \n        try {\n          const evalValue = eval('window.' + widgetTargetName);\n          \n          // Debug.log('NegativeTargetingModule->isBlockedByJavaScriptTag(): ===', evalValue, parsedValue)\n          \n          return evalValue === parsedValue;\n        }\n        catch (e) {\n          // if the value of 'widgetTargetName' is not present onto 'window' scope, the eval() will throw an error\n          return false;\n        }\n      }\n      \n      return false;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to validate the CSS selector\n   */\n  isBlockedByCssSelector(widgetTargetName, widgetTargetValue) {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isBlockedByCssSelector()')\n    \n    try {\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isBlockedByCssSelector(): widgetTargetName', widgetTargetName)\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isBlockedByCssSelector(): widgetTargetValue', widgetTargetValue)\n      \n      if (widgetTargetName) {\n        \n        const selectedElement = document.querySelector(widgetTargetName);\n        _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isBlockedByCssSelector(): selectedElement', selectedElement)\n  \n        return !!selectedElement;\n      }\n      \n      return false;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to validate the URLs\n   */\n  isBlockedByURL(urls) {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isBlockedByURL()');\n    try {\n      let isBlockedByURL = false;\n      const currentURL = global.location.href;\n      \n      // Debug.log('NegativeTargetingModule->isBlockedByURL(): currentURL', currentURL)\n      \n      for (let i in urls) {\n        \n        // Debug.log('NegativeTargetingModule->isBlockedByURL(): urls[i]', urls[i])\n        \n        if (urls[i].url === currentURL) {\n          \n          isBlockedByURL = true;\n          \n          if (urls[i].start_at && urls[i].end_at) {\n            isBlockedByURL = this.isBlockedByDates(urls[i].start_at, urls[i].end_at);\n            // Debug.log('NegativeTargetingModule->isBlockedByURL(): isBlockedByDates', isBlockedByURL)\n          }\n          \n          // Debug.log('NegativeTargetingModule->isBlockedByURL(): isBlockedByURL', isBlockedByURL)\n          \n          break;\n        }\n        \n      }\n      \n      return isBlockedByURL;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to check if the negative target has potential to block the widget\n   */\n  isValidNegativeTarget() {\n    \n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->isValidNegativeTarget()', global.GC_CLIENT_SETTINGS.widget_target_enabled, global.GC_CLIENT_SETTINGS.negative_targets);\n    \n    try {\n      \n      const negative_tags = global.GC_CLIENT_SETTINGS.negative_tags;\n      const negative_targets = global.GC_CLIENT_SETTINGS.negative_targets;\n      \n      if (negative_tags) {\n        \n        for (let i in negative_tags) {\n          \n          const negative = negative_tags[i];\n          \n          // console.log('negative-targeting.module->isValidNegativeTarget(): negative', negative);\n          \n          if (negative.enabled && negative.key) {\n            if (negative.start_at && negative.end_at) {\n              return this.isBlockedByDates(negative.start_at, negative.end_at);\n            }\n            else {\n              return true;\n            }\n          }\n        }\n        \n        if (negative_targets && negative_targets.length) {\n          for (let i in negative_targets) {\n            if (negative_targets[i].url === global.location.href) {\n              return true;\n            }\n          }\n        }\n        \n      }\n      \n      return false;\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to check if the widget has been blocked\n   */\n  isWidgetBlocked() {\n    \n    // Debug.log('NegativeTargetingModule->startNegativeTarget(): isWidgetBlocked')\n    \n    try {\n      \n      const negative_tags = global.GC_CLIENT_SETTINGS.negative_tags;\n      const negative_targets = global.GC_CLIENT_SETTINGS.negative_targets;\n      \n      const validationFunctions = {\n        javascript: this.isBlockedByJavaScriptTag,\n        css_selector: this.isBlockedByCssSelector,\n        metatag: this.isBlockedByMetatag\n      };\n      \n      if (negative_tags) {\n        for (let i in negative_tags) {\n          \n          if (validationFunctions[i]) {\n            \n            const negative = negative_tags[i];\n            \n            if (negative.key !== null) {\n              if (\n                validationFunctions[i](\n                  negative.key,\n                  negative.value\n                )\n              ) {\n                if (negative.start_at && negative.end_at) {\n                  if (this.isBlockedByDates(negative.start_at, negative.end_at)) {\n                    return true;\n                  }\n                }\n                else {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n  \n      return this.isBlockedByURL(negative_targets);\n      \n    }\n    catch (e) {\n      throw e;\n    }\n    \n  }\n  \n  /**\n   * Method to deal with all Negative Targeting processes\n   */\n  async startNegativeTarget() {\n    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget()');\n    try {\n      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget() this.isValidNegativeTarget()', this.isValidNegativeTarget());\n      \n      const negative_tags = global.GC_CLIENT_SETTINGS.negative_tags;\n      \n      if (this.isValidNegativeTarget()) {\n        try {\n          \n          await new Promise((resolve, reject) => {\n            \n            try {\n              let countTimeInterval = 0;\n              let interval = setInterval(() => {\n    \n                countTimeInterval += 500;\n    \n                const isWidgetBlocked = this.isWidgetBlocked();\n    \n                _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget(): isWidgetBlocked', isWidgetBlocked, countTimeInterval);\n    \n                if (isWidgetBlocked) {\n                  clearInterval(interval);\n                  reject();\n                }\n                else if (countTimeInterval >= 5000) {\n      \n                  countTimeInterval = 0;\n                  clearInterval(interval);\n      \n                  interval = setInterval(() => {\n                    countTimeInterval += 500;\n        \n                    const isWidgetBlocked = this.isWidgetBlocked();\n        \n                    _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget(): isWidgetBlocked', isWidgetBlocked, countTimeInterval);\n        \n                    if (isWidgetBlocked) {\n                      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget(): BLOCKED -> Destroying widget');\n                      this.destroyWidgetModule();\n                      clearInterval(interval);\n                      reject();\n                    }\n                    else if (countTimeInterval >= 15000) {\n                      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget(): TIME OUTED -> Keeping widget on PAGE');\n                      clearInterval(interval);\n                    }\n                  }, 500);\n      \n                  resolve();\n                }\n    \n              }, 500);\n  \n              if (negative_tags && negative_tags.post_message) {\n    \n                let isValidPostMessage = true;\n    \n                if (negative_tags.post_message.start_at && negative_tags.post_message.end_at) {\n                  isValidPostMessage = this.isBlockedByDates(\n                    negative_tags.post_message.start_at,\n                    negative_tags.post_message.end_at\n                  );\n                }\n    \n                if (isValidPostMessage) {\n                  window.addEventListener('message', message => {\n                    if (message && message.data === negative_tags.post_message.key) {\n                      _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__[\"default\"].log('NegativeTargetingModule->startNegativeTarget(): BLOCKED by [post_message] -> Destroying widget');\n                      clearInterval(interval);\n                      this.destroyWidgetModule();\n                      reject();\n                    }\n                  });\n                }\n    \n              }\n              \n            }\n            catch (e) {\n              reject(e);\n            }\n            \n          });\n          \n          // has not been blocked\n          return false;\n        }\n        catch (e) {\n          \n          // has been blocked\n          return true;\n        }\n      }\n      else {\n        \n        // has not been blocked because the negative target is not valid or is not blocking at all\n        return false;\n      }\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../var/task/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/negative-targeting.module.js?")},"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/widget.module.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WidgetModule; });\n/* harmony import */ var _models_widget_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/widget.model */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/models/widget.model.js\");\n/* harmony import */ var _factories_debug_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../factories/debug.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/debug.factory.js\");\n/* harmony import */ var _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factories/utils.factory */ \"../../tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/factories/utils.factory.js\");\n// client model dependency\n\n\n// factories dependencies\n\n\n\nclass WidgetModule {\n  \n  constructor() {\n    // console.log('WidgetModule->constructor()')\n    \n    this.widgets = [];\n    this.autoinstallSettings = {};\n    \n    this.hasScrolledOnce = false;\n    this.scrollingDirection = null;\n    \n    // setting 21px so we can trigger the fist widget. The min scroll size is\n    // 20px, so the initial scroll direction will be 'down'.\n    this.lastScrollPosition = 100;\n    this.triggerListenerTimeout = null;\n  }\n  \n  /**\n   * Method to destroy all information on WidgetModule()\n   */\n  destroyWidgetModule() {\n    console.log('WidgetModule->destroyWidgetModule()');\n    try {\n      \n      if (this.triggerListenerTimeout) {\n        clearTimeout(this.triggerListenerTimeout);\n        this.triggerListenerTimeout = null;\n      }\n      \n      this.widgets.forEach(widget => {\n        console.log('WidgetModule->destroyWidgetModule() forEach', widget);\n        widget.destroyWidget();\n      });\n      \n      this.widgets = [];\n      this.hasScrolledOnce = false;\n      this.scrollingDirection = null;\n      this.lastScrollPosition = 100;\n      \n      console.log('WidgetModule->destroyWidgetModule() this.widgets', this.widgets);\n      \n    }\n    catch (e) {\n      console.error(e);\n    }\n  }\n  \n  /**\n   * Method to register a new widget element\n   */\n  registerWidget(el, isAutoinstallSelector, selector) {\n    console.log('WidgetModule->registerWidget(): global.GC_CLIENT_SETTINGS', global.GC_CLIENT_SETTINGS);\n    try {\n      \n      // setting a property to the container element to prevent the watcher to try to register this again.\n      el.setAttribute('gc-widget-has-installed', 'true');\n      \n      let finalContainer = el;\n      let widgetUrl = null;\n      const widgetId = _factories_utils_factory__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateGUID();\n      \n      if (global.GC_CLIENT_SETTINGS.get_from_ssr || global.GC_CLIENT_ENV.CLIENT_ENV_ENV_NAME === 'local') {\n       \n        if (global.GC_CLIENT_SETTINGS.widget_version === 3) {\n          widgetUrl = global.GC_CLIENT_ENV.CLIENT_ENV_SSR_WIDGET_URL_NEW;\n        }\n        else {\n          widgetUrl = global.GC_CLIENT_ENV.CLIENT_ENV_SSR_WIDGET_URL_OLD;\n        }\n        \n      }\n      else {\n        \n        if (global.GC_CLIENT_SETTINGS.widget_version === 3) {\n          widgetUrl = `${global.GC_CLIENT_ENV.CLIENT_ENV_WIDGET_BUCKET_URL_NEW}/carousel/qa/widget`;\n        }\n        else {\n          widgetUrl = `${global.GC_CLIENT_ENV.CLIENT_ENV_WIDGET_BUCKET_URL_OLD}/widget`;\n        }\n        \n        widgetUrl += `/${this.gcid}/index.html`;\n        \n      }\n      \n      console.log('WidgetModule->registerWidget(): global.GC_CLIENT_SETTINGS', global.GC_CLIENT_SETTINGS);\n      console.log('WidgetModule->registerWidget(): widgetUrl', widgetUrl);\n      \n      // if the \"isAutoInstall\" is equals to \"true\", we need to create a new container for\n      // widget into the given container from \"autoinstall\" property\n      if (isAutoinstallSelector) {\n        \n        finalContainer = document.createElement('div');\n        \n        // global.console.timeEnd('GC: Time WIDGET is injected')\n        if (\n          this.autoinstallSettings &&\n          this.autoinstallSettings[selector] &&\n          this.autoinstallSettings[selector].insertion &&\n          this.autoinstallSettings[selector].insertion === 'after'\n        ) {\n          console.log('WidgetModule->registerWidget(): after', finalContainer);\n          // Insert the new element after the container node\n          el.parentNode.insertBefore(finalContainer, el.nextSibling);\n        }\n        else {\n          console.log('WidgetModule->registerWidget(): appendChild', finalContainer);\n          // Insert the new element after the last element within container node\n          el.appendChild(finalContainer);\n        }\n        \n      }\n      \n      finalContainer.setAttribute('widget-id', widgetId);\n      \n      console.log('WidgetModule->registerWidget(): widgetUrl', widgetUrl);\n      \n      // creating a new widget model instance. The widget is a singleton\n      // object, it means each widget has its on properties and wont be created again\n      const widgetModel = new _models_widget_model__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n        parentContainer: el,\n        container: finalContainer,\n        gcid: this.gcid,\n        widget_id: widgetId,\n        widget_url: widgetUrl,\n        widget_core: this,\n        enable_cache: global.GC_CLIENT_ENV.CLIENT_ENV_ENV_NAME !== 'local',\n        ...global.GC_CLIENT_SETTINGS\n      });\n      console.log('WidgetModule->registerWidget(): widgetModel', widgetModel);\n      \n      // pushing the new widget into the lib\n      this.widgets.push(widgetModel);\n      \n      // resetting the \"scrollingDirection\" to \"down\" so the \"getClosestViewport()\" can reevaluate all widgets\n      this.scrollingDirection = 'down';\n      \n      // setting the widget position index\n      widgetModel.widget_index = this.widgets.indexOf(widgetModel);\n      \n      // if the current instance is not the fist widget created, we can now define\n      // its siblings. This will help control the prev/next enable/disable based\n      // on the proximity\n      if (widgetModel.widget_index > 0) {\n        const prevWidgetModel = this.widgets[widgetModel.widget_index - 1];\n        widgetModel.prev_widget_model = prevWidgetModel;\n        prevWidgetModel.next_widget_model = widgetModel;\n      }\n      \n      console.log('WidgetModule->registerWidget(): widgetModel', widgetModel);\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to enable/disable the closest/furthest widget element\n   */\n  getClosestViewport() {\n    \n    // console.log('WidgetModule->getClosestViewport()')\n    \n    try {\n      \n      let widgetModelWithinViewport = null;\n      let listWidgetsDistance = [];\n      let allWidgetsByDistance = {};\n      let closesWidgetModel = null;\n      \n      const listWidgetToRemove = [];\n      \n      // console.log('WidgetModule->getClosestViewport(): this.scrollingDirection', this.scrollingDirection)\n      \n      // updating the las scroll position\n      // this.lastScrollPosition = document.querySelector('body, html').scrollTop\n      \n      if (this.widgets.length && this.widgets[0]) {\n        // console.log('WidgetModule->getClosestViewport(): getBoundingClientRect', this.widgets[0].widget_id,\n        // this.widgets[0].container.getBoundingClientRect())\n        \n        // console.log('WidgetModule->getClosestViewport() ----------------------------------')\n        // console.log('WidgetModule->getClosestViewport(): this.scrollingDirection', this.lastScrollPosition,\n        // this.scrollingDirection)\n        \n        // has the user scrolled? we just control widget enable/disable when the user is scrolling\n        if (this.scrollingDirection) {\n          \n          for (const widgetModel of this.widgets) {\n            \n            // console.log('WidgetModule->getClosestViewport(): querySelector', widgetModel.widget_id,\n            // document.querySelector(`[widget-id=\"${widgetModel.widget_id}\"]`))\n            \n            if (document.querySelector(`[widget-id=\"${widgetModel.widget_id}\"]`)) {\n              \n              const container = widgetModel.container;\n              const boundingRect = container.getBoundingClientRect();\n              \n              // is widget bottom border below viewport top edge?\n              const isBottomBorderAboveTopEdge = boundingRect.bottom >= 0;\n              \n              // is widget top border above viewport bottom edge?\n              const isTopBorderAboveBottomEdge = (boundingRect.bottom - boundingRect.height) <= window.innerHeight;\n              \n              // get the distance of the current widget\n              const widgetDistance = (boundingRect.top < 0 ? boundingRect.top * (-1) : boundingRect.top);\n              \n              // pushing all the widgets distances into a list so we know which one is closer\n              listWidgetsDistance.push(widgetDistance);\n              allWidgetsByDistance[widgetDistance] = widgetModel;\n              \n              // console.log('WidgetModule->getClosestViewport(): widgetModelWithinViewport', isBottomBorderAboveTopEdge,\n              // isTopBorderAboveBottomEdge, container)\n              \n              // is the current widget partially or fully into the view?\n              if (isBottomBorderAboveTopEdge && isTopBorderAboveBottomEdge) {\n                \n                // if so, get this widgetModel as the closes one.\n                widgetModelWithinViewport = widgetModel;\n                break;\n              }\n            }\n            else {\n              listWidgetToRemove.push(widgetModel);\n            }\n            \n          }\n          \n          // console.log('WidgetModule->getClosestViewport(): widgetModelWithinViewport', widgetModelWithinViewport)\n          \n          if (listWidgetToRemove.length) {\n            for (let widgetModel of listWidgetToRemove) {\n              this.widgets.splice(this.widgets.indexOf(widgetModel), 1);\n            }\n          }\n          \n          // console.log('WidgetModule->getClosestViewport(): listWidgetsDistance', listWidgetsDistance)\n          \n          // if no widget is into viewport, not even a pixel of it, we will get the\n          // closes one based on smallest distance (in px)\n          if (!widgetModelWithinViewport && listWidgetsDistance.length) {\n            const closerDistance = Math.min.apply(null, listWidgetsDistance);\n            widgetModelWithinViewport = allWidgetsByDistance[closerDistance];\n          }\n          \n          if (widgetModelWithinViewport) {\n            closesWidgetModel = {\n              widgetModel: widgetModelWithinViewport,\n              direction: this.scrollingDirection\n            };\n          }\n        }\n        \n        // console.log('WidgetModule->getClosestViewport(): this.widgets[0].container', this.widgets[0].container);\n        \n        // if (this.widgets[0].container) {\n        \n        // getting the current window scroll position\n        const boundingRectFirstWidget = this.widgets[0].container.getBoundingClientRect();\n        const currentScrollPosition = boundingRectFirstWidget.top; // document.querySelector('body, html').scrollTop\n        \n        // is the current scroll position greater then 20px, is yes, it\n        // means that the user has scrolled DOWN\n        if ((currentScrollPosition - this.lastScrollPosition) > 20) {\n          this.scrollingDirection = 'up';\n          this.hasScrolledOnce = true;\n        }\n          \n          // is the current scroll position less then -20px, is yes, it\n        // means that the user has scrolled UP\n        else if ((currentScrollPosition - this.lastScrollPosition) < (-20)) {\n          this.scrollingDirection = 'down';\n          this.hasScrolledOnce = true;\n        }\n          \n          // if not greater then 20px or less then -20px, we are assuming\n        // that the user has not scrolling at all\n        else {\n          this.scrollingDirection = null;\n        }\n        \n        this.lastScrollPosition = boundingRectFirstWidget.top;\n        \n        // }\n        \n      }\n      \n      return closesWidgetModel;\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to deal with the eneble/disable the closest widget\n   */\n  async enebleWidgetProcess(scrollingOptions) {\n    try {\n      \n      // console.log('WidgetModule->enebleWidgetProcess(): scrollingOptions', scrollingOptions)\n      \n      let whileLimitCount = 0;\n      \n      const widgetModel = scrollingOptions.widgetModel;\n      const scrollingDirection = scrollingOptions.direction;\n      \n      let prevWidgetModel = widgetModel.prev_widget_model;\n      let nextWidgetModel = widgetModel.next_widget_model;\n      \n      // render the closest widget to the viewport\n      await widgetModel.renderWidget();\n      \n      // is the the closest widget already into viewport?\n      if (widgetModel.is_into_viewport) {\n        \n        // if the user is scrolling downwards, let's start the autoRemoveWidget()\n        // to remove up to 5 widgets upwards\n        if (scrollingDirection === 'down') {\n          \n          while (prevWidgetModel && whileLimitCount < 5) {\n            \n            whileLimitCount++;\n            \n            if (prevWidgetModel) {\n              \n              // trigger the \"autoRemoveWidget()\". This wont remove the widget\n              // right away. It has a timeout of 10secs, so if the user scroll\n              // upwards again, we can cancel the removal\n              prevWidgetModel.autoRemoveWidget();\n            }\n            \n            prevWidgetModel = prevWidgetModel.prev_widget_model;\n          }\n          \n          // is there a above widget?\n          if (nextWidgetModel) {\n            \n            // if so, let's render this widget right away\n            nextWidgetModel.renderWidget();\n          }\n          \n        }\n        \n        // if the user is scrolling upwards, let's start the autoRemoveWidget()\n        // to remove up to 5 widgets downwards\n        if (scrollingDirection === 'up') {\n          \n          if (prevWidgetModel) {\n            prevWidgetModel.renderWidget();\n          }\n          \n          while (nextWidgetModel && whileLimitCount < 5) {\n            \n            whileLimitCount++;\n            \n            if (nextWidgetModel) {\n              \n              // triggering the \"autoRemoveWidget()\". This wont remove the widget\n              // right away. It has a timeout of 10secs, so if the user scroll\n              // downwards again, we can cancel the removal\n              nextWidgetModel.autoRemoveWidget();\n            }\n            \n            nextWidgetModel = nextWidgetModel.next_widget_model;\n          }\n          \n        }\n        \n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to deal with widgets container\n   */\n  triggerListener(isAutoInstall, isAutoinstallSelector) {\n    try {\n      \n      this.widgetSelector.forEach(selector => {\n        \n        // select all widgets elements\n        const widgetElements = document.querySelectorAll(selector);\n        \n        // console.log('WidgetModule->triggerListener(): widgetElements', widgetElements)\n        // console.log('WidgetModule->triggerListener(): this.widgets', this.widgets.length)\n        // console.log('WidgetModule->triggerListener(): this.widgets', isAutoInstall, this.widgets.length)\n        \n        // checking if there are node resolved element\n        widgetElements.forEach(el => {\n          if (!el.hasAttribute('gc-widget-has-installed')) {\n            // console.log('WidgetModule->triggerListener(): el', el)\n            this.registerWidget(el, isAutoinstallSelector, selector);\n          }\n        });\n        \n      });\n      \n      if (!global.GC_CLIENT_SETTINGS.widget_lazy_loading) {\n        \n        // get the closest widget to viewport (or the widget that is already into viewport)\n        const closesWidgetModel = this.getClosestViewport();\n        // console.log('WidgetModule->triggerListener(): closesWidgetModel', closesWidgetModel);\n        \n        // was any data returned? If not, it means that the user may not scroll lately. We\n        // deal with eneble/disable just when user is scrolling\n        if (closesWidgetModel) {\n          // console.log('WidgetModule->triggerListener(): closesWidgetModel', closesWidgetModel);\n          \n          // deal with enable/disable widgets on/close to viewport\n          this.enebleWidgetProcess(closesWidgetModel, this.scrollingDirection);\n        }\n        \n      }\n      \n      if (isAutoInstall) {\n        \n        // trigger itself recursively, so we can control widgets enable/disable\n        this.triggerListenerTimeout = setTimeout(() => {\n          this.triggerListener(isAutoInstall);\n        }, 300);\n      }\n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n  /**\n   * Method to start all the injection widget process\n   */\n  startWidget(widgetOptions) {\n    console.log('WidgetModule->startWidget(): widgetOptions', widgetOptions, this.gcid);\n    try {\n      \n      this.destroyWidgetModule();\n      \n      let isAutoinstallSelector = false;\n      \n      // default widget containers selectors. Preserving all old selectors to keep compatible.\n      this.widgetSelector = ['.gcwp-carousel', '.gcwp-carousel-single', '.gcwp-carousel-multi'];\n      \n      // was autoinstall provided?\n      if (widgetOptions && widgetOptions.autoinstall && Array.isArray(widgetOptions.autoinstall)) {\n        \n        this.widgetSelector = [];\n        \n        widgetOptions.autoinstall.forEach(item => {\n          // was a custom selector provided?\n          if (item.selector) {\n            this.widgetSelector.push(item.selector);\n            isAutoinstallSelector = true;\n            this.autoinstallSettings[item.selector] = item;\n          }\n        });\n      }\n      \n      console.log('WidgetModule->startWidget(): isAutoinstallSelector', isAutoinstallSelector, this.widgetSelector);\n      \n      // kickoff the listener process\n      setTimeout(() => {\n        this.triggerListener(global.GC_CLIENT_SETTINGS.disable_auto_install !== true, isAutoinstallSelector);\n      }, 1);\n      \n    }\n    catch (e) {\n      throw e;\n    }\n  }\n  \n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../var/task/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:////tmp/GC_e4431c0a82261742f007d36f767de82097f19bc6/client/modules/widget.module.js?")},"./node_modules/@bugsnag/browser/dist/bugsnag.js":function(module,exports,__webpack_require__){eval("(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;\nvar _$breadcrumbTypes_8 = ['navigation', 'request', 'process', 'log', 'user', 'state', 'error', 'manual'];\n\n// Array#reduce\nvar _$reduce_17 = function (arr, fn, accum) {\n  var val = accum;\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    val = fn(val, arr[i], i, arr);\n  }\n\n  return val;\n};\n\n/* removed: var _$reduce_17 = require('./reduce'); */; // Array#filter\n\n\nvar _$filter_12 = function (arr, fn) {\n  return _$reduce_17(arr, function (accum, item, i, arr) {\n    return !fn(item, i, arr) ? accum : accum.concat(item);\n  }, []);\n};\n\n/* removed: var _$reduce_17 = require('./reduce'); */; // Array#includes\n\n\nvar _$includes_13 = function (arr, x) {\n  return _$reduce_17(arr, function (accum, item, i, arr) {\n    return accum === true || item === x;\n  }, false);\n};\n\n// Array#isArray\nvar _$isArray_14 = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\n/* eslint-disable-next-line no-prototype-builtins */\nvar _hasDontEnumBug = !{\n  toString: null\n}.propertyIsEnumerable('toString');\n\nvar _dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor']; // Object#keys\n\nvar _$keys_15 = function (obj) {\n  // stripped down version of\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/Keys\n  var result = [];\n  var prop;\n\n  for (prop in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, prop)) result.push(prop);\n  }\n\n  if (!_hasDontEnumBug) return result;\n\n  for (var i = 0, len = _dontEnums.length; i < len; i++) {\n    if (Object.prototype.hasOwnProperty.call(obj, _dontEnums[i])) result.push(_dontEnums[i]);\n  }\n\n  return result;\n};\n\nvar _$intRange_24 = function (min, max) {\n  if (min === void 0) {\n    min = 1;\n  }\n\n  if (max === void 0) {\n    max = Infinity;\n  }\n\n  return function (value) {\n    return typeof value === 'number' && parseInt('' + value, 10) === value && value >= min && value <= max;\n  };\n};\n\n/* removed: var _$filter_12 = require('../es-utils/filter'); */;\n\n/* removed: var _$isArray_14 = require('../es-utils/is-array'); */;\n\nvar _$listOfFunctions_25 = function (value) {\n  return typeof value === 'function' || _$isArray_14(value) && _$filter_12(value, function (f) {\n    return typeof f === 'function';\n  }).length === value.length;\n};\n\nvar _$stringWithLength_26 = function (value) {\n  return typeof value === 'string' && !!value.length;\n};\n\nvar _$config_5 = {};\n/* removed: var _$filter_12 = require('./lib/es-utils/filter'); */;\n\n/* removed: var _$reduce_17 = require('./lib/es-utils/reduce'); */;\n\n/* removed: var _$keys_15 = require('./lib/es-utils/keys'); */;\n\n/* removed: var _$isArray_14 = require('./lib/es-utils/is-array'); */;\n\n/* removed: var _$includes_13 = require('./lib/es-utils/includes'); */;\n\n/* removed: var _$intRange_24 = require('./lib/validators/int-range'); */;\n\n/* removed: var _$stringWithLength_26 = require('./lib/validators/string-with-length'); */;\n\n/* removed: var _$listOfFunctions_25 = require('./lib/validators/list-of-functions'); */;\n\n/* removed: var _$breadcrumbTypes_8 = require('./lib/breadcrumb-types'); */;\n\nvar defaultErrorTypes = function () {\n  return {\n    unhandledExceptions: true,\n    unhandledRejections: true\n  };\n};\n\n_$config_5.schema = {\n  apiKey: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'is required',\n    validate: _$stringWithLength_26\n  },\n  appVersion: {\n    defaultValue: function () {\n      return undefined;\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return value === undefined || _$stringWithLength_26(value);\n    }\n  },\n  appType: {\n    defaultValue: function () {\n      return undefined;\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return value === undefined || _$stringWithLength_26(value);\n    }\n  },\n  autoDetectErrors: {\n    defaultValue: function () {\n      return true;\n    },\n    message: 'should be true|false',\n    validate: function (value) {\n      return value === true || value === false;\n    }\n  },\n  enabledErrorTypes: {\n    defaultValue: function () {\n      return defaultErrorTypes();\n    },\n    message: 'should be an object containing the flags { unhandledExceptions:true|false, unhandledRejections:true|false }',\n    allowPartialObject: true,\n    validate: function (value) {\n      // ensure we have an object\n      if (typeof value !== 'object' || !value) return false;\n      var providedKeys = _$keys_15(value);\n      var defaultKeys = _$keys_15(defaultErrorTypes()); // ensure it only has a subset of the allowed keys\n\n      if (_$filter_12(providedKeys, function (k) {\n        return _$includes_13(defaultKeys, k);\n      }).length < providedKeys.length) return false; // ensure all of the values are boolean\n\n      if (_$filter_12(_$keys_15(value), function (k) {\n        return typeof value[k] !== 'boolean';\n      }).length > 0) return false;\n      return true;\n    }\n  },\n  onError: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be a function or array of functions',\n    validate: _$listOfFunctions_25\n  },\n  onSession: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be a function or array of functions',\n    validate: _$listOfFunctions_25\n  },\n  onBreadcrumb: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be a function or array of functions',\n    validate: _$listOfFunctions_25\n  },\n  endpoints: {\n    defaultValue: function () {\n      return {\n        notify: 'https://notify.bugsnag.com',\n        sessions: 'https://sessions.bugsnag.com'\n      };\n    },\n    message: 'should be an object containing endpoint URLs { notify, sessions }',\n    validate: function (val) {\n      return (// first, ensure it's an object\n        val && typeof val === 'object' && // notify and sessions must always be set\n        _$stringWithLength_26(val.notify) && _$stringWithLength_26(val.sessions) && // ensure no keys other than notify/session are set on endpoints object\n        _$filter_12(_$keys_15(val), function (k) {\n          return !_$includes_13(['notify', 'sessions'], k);\n        }).length === 0\n      );\n    }\n  },\n  autoTrackSessions: {\n    defaultValue: function (val) {\n      return true;\n    },\n    message: 'should be true|false',\n    validate: function (val) {\n      return val === true || val === false;\n    }\n  },\n  enabledReleaseStages: {\n    defaultValue: function () {\n      return null;\n    },\n    message: 'should be an array of strings',\n    validate: function (value) {\n      return value === null || _$isArray_14(value) && _$filter_12(value, function (f) {\n        return typeof f === 'string';\n      }).length === value.length;\n    }\n  },\n  releaseStage: {\n    defaultValue: function () {\n      return 'production';\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return typeof value === 'string' && value.length;\n    }\n  },\n  maxBreadcrumbs: {\n    defaultValue: function () {\n      return 25;\n    },\n    message: 'should be a number ≤100',\n    validate: function (value) {\n      return _$intRange_24(0, 100)(value);\n    }\n  },\n  enabledBreadcrumbTypes: {\n    defaultValue: function () {\n      return _$breadcrumbTypes_8;\n    },\n    message: \"should be null or a list of available breadcrumb types (\" + _$breadcrumbTypes_8.join(',') + \")\",\n    validate: function (value) {\n      return value === null || _$isArray_14(value) && _$reduce_17(value, function (accum, maybeType) {\n        if (accum === false) return accum;\n        return _$includes_13(_$breadcrumbTypes_8, maybeType);\n      }, true);\n    }\n  },\n  context: {\n    defaultValue: function () {\n      return undefined;\n    },\n    message: 'should be a string',\n    validate: function (value) {\n      return value === undefined || typeof value === 'string';\n    }\n  },\n  user: {\n    defaultValue: function () {\n      return {};\n    },\n    message: 'should be an object with { id, email, name } properties',\n    validate: function (value) {\n      return value === null || value && _$reduce_17(_$keys_15(value), function (accum, key) {\n        return accum && _$includes_13(['id', 'email', 'name'], key);\n      }, true);\n    }\n  },\n  metadata: {\n    defaultValue: function () {\n      return {};\n    },\n    message: 'should be an object',\n    validate: function (value) {\n      return typeof value === 'object' && value !== null;\n    }\n  },\n  logger: {\n    defaultValue: function () {\n      return undefined;\n    },\n    message: 'should be null or an object with methods { debug, info, warn, error }',\n    validate: function (value) {\n      return !value || value && _$reduce_17(['debug', 'info', 'warn', 'error'], function (accum, method) {\n        return accum && typeof value[method] === 'function';\n      }, true);\n    }\n  },\n  redactedKeys: {\n    defaultValue: function () {\n      return ['password'];\n    },\n    message: 'should be an array of strings|regexes',\n    validate: function (value) {\n      return _$isArray_14(value) && value.length === _$filter_12(value, function (s) {\n        return typeof s === 'string' || s && typeof s.test === 'function';\n      }).length;\n    }\n  },\n  plugins: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be an array of plugin objects',\n    validate: function (value) {\n      return _$isArray_14(value) && value.length === _$filter_12(value, function (p) {\n        return p && typeof p === 'object' && typeof p.load === 'function';\n      }).length;\n    }\n  },\n  featureFlags: {\n    defaultValue: function () {\n      return [];\n    },\n    message: 'should be an array of objects that have a \"name\" property',\n    validate: function (value) {\n      return _$isArray_14(value) && value.length === _$filter_12(value, function (feature) {\n        return feature && typeof feature === 'object' && typeof feature.name === 'string';\n      }).length;\n    }\n  }\n};\n\n// extends helper from babel\n// https://github.com/babel/babel/blob/916429b516e6466fd06588ee820e40e025d7f3a3/packages/babel-helpers/src/helpers.js#L377-L393\nvar _$assign_11 = function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/* removed: var _$reduce_17 = require('./reduce'); */; // Array#map\n\n\nvar _$map_16 = function (arr, fn) {\n  return _$reduce_17(arr, function (accum, item, i, arr) {\n    return accum.concat(fn(item, i, arr));\n  }, []);\n};\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar schema = _$config_5.schema;\n\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$assign_11 = require('@bugsnag/core/lib/es-utils/assign'); */;\n\nvar _$config_1 = {\n  releaseStage: _$assign_11({}, schema.releaseStage, {\n    defaultValue: function () {\n      if (/^localhost(:\\d+)?$/.test(window.location.host)) return 'development';\n      return 'production';\n    }\n  }),\n  appType: _extends({}, schema.appType, {\n    defaultValue: function () {\n      return 'browser';\n    }\n  }),\n  logger: _$assign_11({}, schema.logger, {\n    defaultValue: function () {\n      return (// set logger based on browser capability\n        typeof console !== 'undefined' && typeof console.debug === 'function' ? getPrefixedConsole() : undefined\n      );\n    }\n  })\n};\n\nvar getPrefixedConsole = function () {\n  var logger = {};\n  var consoleLog = console.log;\n  _$map_16(['debug', 'info', 'warn', 'error'], function (method) {\n    var consoleMethod = console[method];\n    logger[method] = typeof consoleMethod === 'function' ? consoleMethod.bind(console, '[bugsnag]') : consoleLog.bind(console, '[bugsnag]');\n  });\n  return logger;\n};\n\nvar Breadcrumb = /*#__PURE__*/function () {\n  function Breadcrumb(message, metadata, type, timestamp) {\n    if (timestamp === void 0) {\n      timestamp = new Date();\n    }\n\n    this.type = type;\n    this.message = message;\n    this.metadata = metadata;\n    this.timestamp = timestamp;\n  }\n\n  var _proto = Breadcrumb.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      type: this.type,\n      name: this.message,\n      timestamp: this.timestamp,\n      metaData: this.metadata\n    };\n  };\n\n  return Breadcrumb;\n}();\n\nvar _$Breadcrumb_3 = Breadcrumb;\n\nvar _$stackframe_34 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stackframe', [], factory);\n  } else if (typeof _$stackframe_34 === 'object') {\n    _$stackframe_34 = factory();\n  } else {\n    root.StackFrame = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  function _isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  }\n\n  function _getter(p) {\n    return function () {\n      return this[p];\n    };\n  }\n\n  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n  var numericProps = ['columnNumber', 'lineNumber'];\n  var stringProps = ['fileName', 'functionName', 'source'];\n  var arrayProps = ['args'];\n  var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n  function StackFrame(obj) {\n    if (obj instanceof Object) {\n      for (var i = 0; i < props.length; i++) {\n        if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n          this['set' + _capitalize(props[i])](obj[props[i]]);\n        }\n      }\n    }\n  }\n\n  StackFrame.prototype = {\n    getArgs: function () {\n      return this.args;\n    },\n    setArgs: function (v) {\n      if (Object.prototype.toString.call(v) !== '[object Array]') {\n        throw new TypeError('Args must be an Array');\n      }\n\n      this.args = v;\n    },\n    getEvalOrigin: function () {\n      return this.evalOrigin;\n    },\n    setEvalOrigin: function (v) {\n      if (v instanceof StackFrame) {\n        this.evalOrigin = v;\n      } else if (v instanceof Object) {\n        this.evalOrigin = new StackFrame(v);\n      } else {\n        throw new TypeError('Eval Origin must be an Object or StackFrame');\n      }\n    },\n    toString: function () {\n      var functionName = this.getFunctionName() || '{anonymous}';\n      var args = '(' + (this.getArgs() || []).join(',') + ')';\n      var fileName = this.getFileName() ? '@' + this.getFileName() : '';\n      var lineNumber = _isNumber(this.getLineNumber()) ? ':' + this.getLineNumber() : '';\n      var columnNumber = _isNumber(this.getColumnNumber()) ? ':' + this.getColumnNumber() : '';\n      return functionName + args + fileName + lineNumber + columnNumber;\n    }\n  };\n\n  for (var i = 0; i < booleanProps.length; i++) {\n    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n\n    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {\n      return function (v) {\n        this[p] = Boolean(v);\n      };\n    }(booleanProps[i]);\n  }\n\n  for (var j = 0; j < numericProps.length; j++) {\n    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n\n    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {\n      return function (v) {\n        if (!_isNumber(v)) {\n          throw new TypeError(p + ' must be a Number');\n        }\n\n        this[p] = Number(v);\n      };\n    }(numericProps[j]);\n  }\n\n  for (var k = 0; k < stringProps.length; k++) {\n    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n\n    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {\n      return function (v) {\n        this[p] = String(v);\n      };\n    }(stringProps[k]);\n  }\n\n  return StackFrame;\n});\n\nvar _$errorStackParser_31 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('error-stack-parser', ['stackframe'], factory);\n  } else if (typeof _$errorStackParser_31 === 'object') {\n    _$errorStackParser_31 = factory(_$stackframe_34);\n  } else {\n    root.ErrorStackParser = factory(root.StackFrame);\n  }\n})(this, function ErrorStackParser(StackFrame) {\n  'use strict';\n\n  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n  var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n  return {\n    /**\n     * Given an Error object, extract the most information from it.\n     *\n     * @param {Error} error object\n     * @return {Array} of StackFrames\n     */\n    parse: function ErrorStackParser$$parse(error) {\n      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n        return this.parseOpera(error);\n      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n        return this.parseV8OrIE(error);\n      } else if (error.stack) {\n        return this.parseFFOrSafari(error);\n      } else {\n        throw new Error('Cannot parse given Error object');\n      }\n    },\n    // Separate line and column numbers from a string of the form: (URI:Line:Column)\n    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n      // Fail-fast but return locations like \"(native)\"\n      if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n      }\n\n      var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n      var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n      return [parts[1], parts[2] || undefined, parts[3] || undefined];\n    },\n    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        if (line.indexOf('(eval ') > -1) {\n          // Throw away eval information until we implement stacktrace.js/stackframe#8\n          line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n        }\n\n        var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '('); // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n        // case it has spaces in it, as the string is split on \\s+ later on\n\n        var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/); // remove the parenthesized location from the line, if it was matched\n\n        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n        var tokens = sanitizedLine.split(/\\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token\n\n        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n        return new StackFrame({\n          functionName: functionName,\n          fileName: fileName,\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    },\n    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n      }, this);\n      return filtered.map(function (line) {\n        // Throw away eval information until we implement stacktrace.js/stackframe#8\n        if (line.indexOf(' > eval') > -1) {\n          line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n        }\n\n        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n          // Safari eval frames only have function names and nothing else\n          return new StackFrame({\n            functionName: line\n          });\n        } else {\n          var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n          var matches = line.match(functionNameRegex);\n          var functionName = matches && matches[1] ? matches[1] : undefined;\n          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n          return new StackFrame({\n            functionName: functionName,\n            fileName: locationParts[0],\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            source: line\n          });\n        }\n      }, this);\n    },\n    parseOpera: function ErrorStackParser$$parseOpera(e) {\n      if (!e.stacktrace || e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\n        return this.parseOpera9(e);\n      } else if (!e.stack) {\n        return this.parseOpera10(e);\n      } else {\n        return this.parseOpera11(e);\n      }\n    },\n    parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n      var lines = e.message.split('\\n');\n      var result = [];\n\n      for (var i = 2, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n      var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n      var lines = e.stacktrace.split('\\n');\n      var result = [];\n\n      for (var i = 0, len = lines.length; i < len; i += 2) {\n        var match = lineRE.exec(lines[i]);\n\n        if (match) {\n          result.push(new StackFrame({\n            functionName: match[3] || undefined,\n            fileName: match[2],\n            lineNumber: match[1],\n            source: lines[i]\n          }));\n        }\n      }\n\n      return result;\n    },\n    // Opera 10.65+ Error.stack very similar to FF/Safari\n    parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n      var filtered = error.stack.split('\\n').filter(function (line) {\n        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n      }, this);\n      return filtered.map(function (line) {\n        var tokens = line.split('@');\n        var locationParts = this.extractLocation(tokens.pop());\n        var functionCall = tokens.shift() || '';\n        var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, '$2').replace(/\\([^\\)]*\\)/g, '') || undefined;\n        var argsRaw;\n\n        if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n          argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n        }\n\n        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');\n        return new StackFrame({\n          functionName: functionName,\n          args: args,\n          fileName: locationParts[0],\n          lineNumber: locationParts[1],\n          columnNumber: locationParts[2],\n          source: line\n        });\n      }, this);\n    }\n  };\n});\n\nvar _$errorStackParser_10 = _$errorStackParser_31;\n\nvar _$safeJsonStringify_30 = function (data, replacer, space, opts) {\n  var redactedKeys = opts && opts.redactedKeys ? opts.redactedKeys : [];\n  var redactedPaths = opts && opts.redactedPaths ? opts.redactedPaths : [];\n  return JSON.stringify(prepareObjForSerialization(data, redactedKeys, redactedPaths), replacer, space);\n};\n\nvar MAX_DEPTH = 20;\nvar MAX_EDGES = 25000;\nvar MIN_PRESERVED_DEPTH = 8;\nvar REPLACEMENT_NODE = '...';\n\nfunction isError(o) {\n  return o instanceof Error || /^\\[object (Error|(Dom)?Exception)\\]$/.test(Object.prototype.toString.call(o));\n}\n\nfunction throwsMessage(err) {\n  return '[Throws: ' + (err ? err.message : '?') + ']';\n}\n\nfunction find(haystack, needle) {\n  for (var i = 0, len = haystack.length; i < len; i++) {\n    if (haystack[i] === needle) return true;\n  }\n\n  return false;\n} // returns true if the string `path` starts with any of the provided `paths`\n\n\nfunction isDescendent(paths, path) {\n  for (var i = 0, len = paths.length; i < len; i++) {\n    if (path.indexOf(paths[i]) === 0) return true;\n  }\n\n  return false;\n}\n\nfunction shouldRedact(patterns, key) {\n  for (var i = 0, len = patterns.length; i < len; i++) {\n    if (typeof patterns[i] === 'string' && patterns[i].toLowerCase() === key.toLowerCase()) return true;\n    if (patterns[i] && typeof patterns[i].test === 'function' && patterns[i].test(key)) return true;\n  }\n\n  return false;\n}\n\nfunction __isArray_30(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction safelyGetProp(obj, prop) {\n  try {\n    return obj[prop];\n  } catch (err) {\n    return throwsMessage(err);\n  }\n}\n\nfunction prepareObjForSerialization(obj, redactedKeys, redactedPaths) {\n  var seen = []; // store references to objects we have seen before\n\n  var edges = 0;\n\n  function visit(obj, path) {\n    function edgesExceeded() {\n      return path.length > MIN_PRESERVED_DEPTH && edges > MAX_EDGES;\n    }\n\n    edges++;\n    if (path.length > MAX_DEPTH) return REPLACEMENT_NODE;\n    if (edgesExceeded()) return REPLACEMENT_NODE;\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (find(seen, obj)) return '[Circular]';\n    seen.push(obj);\n\n    if (typeof obj.toJSON === 'function') {\n      try {\n        // we're not going to count this as an edge because it\n        // replaces the value of the currently visited object\n        edges--;\n        var fResult = visit(obj.toJSON(), path);\n        seen.pop();\n        return fResult;\n      } catch (err) {\n        return throwsMessage(err);\n      }\n    }\n\n    var er = isError(obj);\n\n    if (er) {\n      edges--;\n      var eResult = visit({\n        name: obj.name,\n        message: obj.message\n      }, path);\n      seen.pop();\n      return eResult;\n    }\n\n    if (__isArray_30(obj)) {\n      var aResult = [];\n\n      for (var i = 0, len = obj.length; i < len; i++) {\n        if (edgesExceeded()) {\n          aResult.push(REPLACEMENT_NODE);\n          break;\n        }\n\n        aResult.push(visit(obj[i], path.concat('[]')));\n      }\n\n      seen.pop();\n      return aResult;\n    }\n\n    var result = {};\n\n    try {\n      for (var prop in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, prop)) continue;\n\n        if (isDescendent(redactedPaths, path.join('.')) && shouldRedact(redactedKeys, prop)) {\n          result[prop] = '[REDACTED]';\n          continue;\n        }\n\n        if (edgesExceeded()) {\n          result[prop] = REPLACEMENT_NODE;\n          break;\n        }\n\n        result[prop] = visit(safelyGetProp(obj, prop), path.concat(prop));\n      }\n    } catch (e) {}\n\n    seen.pop();\n    return result;\n  }\n\n  return visit(obj, []);\n}\n\n/* removed: var _$map_16 = require('./es-utils/map'); */;\n\n/* removed: var _$keys_15 = require('./es-utils/keys'); */;\n\n/* removed: var _$isArray_14 = require('./es-utils/is-array'); */;\n\n/* removed: var _$safeJsonStringify_30 = require('@bugsnag/safe-json-stringify'); */;\n\nfunction add(existingFeatures, name, variant) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  if (variant === undefined) {\n    variant = null;\n  } else if (variant !== null && typeof variant !== 'string') {\n    variant = _$safeJsonStringify_30(variant);\n  }\n\n  existingFeatures[name] = variant;\n}\n\nfunction merge(existingFeatures, newFeatures) {\n  if (!_$isArray_14(newFeatures)) {\n    return;\n  }\n\n  for (var i = 0; i < newFeatures.length; ++i) {\n    var feature = newFeatures[i];\n\n    if (feature === null || typeof feature !== 'object') {\n      continue;\n    } // 'add' will handle if 'name' doesn't exist & 'variant' is optional\n\n\n    add(existingFeatures, feature.name, feature.variant);\n  }\n} // convert feature flags from a map of 'name -> variant' into the format required\n// by the Bugsnag Event API:\n//   [{ featureFlag: 'name', variant: 'variant' }, { featureFlag: 'name 2' }]\n\n\nfunction toEventApi(featureFlags) {\n  return _$map_16(_$keys_15(featureFlags), function (name) {\n    var flag = {\n      featureFlag: name\n    }; // don't add a 'variant' property unless there's actually a value\n\n    if (typeof featureFlags[name] === 'string') {\n      flag.variant = featureFlags[name];\n    }\n\n    return flag;\n  });\n}\n\nvar _$featureFlagDelegate_18 = {\n  add: add,\n  merge: merge,\n  toEventApi: toEventApi\n};\n\n// Given `err` which may be an error, does it have a stack property which is a string?\nvar _$hasStack_19 = function (err) {\n  return !!err && (!!err.stack || !!err.stacktrace || !!err['opera#sourceloc']) && typeof (err.stack || err.stacktrace || err['opera#sourceloc']) === 'string' && err.stack !== err.name + \": \" + err.message;\n};\n\n/**\n * Expose `isError`.\n */\nvar _$isError_32 = __isError_32;\n/**\n * Test whether `value` is error object.\n *\n * @param {*} value\n * @returns {boolean}\n */\n\nfunction __isError_32(value) {\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Error]':\n      return true;\n\n    case '[object Exception]':\n      return true;\n\n    case '[object DOMException]':\n      return true;\n\n    default:\n      return value instanceof Error;\n  }\n}\n\nvar _$iserror_20 = _$isError_32;\n\n/* removed: var _$assign_11 = require('./es-utils/assign'); */;\n\nvar __add_22 = function (state, section, keyOrObj, maybeVal) {\n  var _updates;\n\n  if (!section) return;\n  var updates; // addMetadata(\"section\", null) -> clears section\n\n  if (keyOrObj === null) return clear(state, section); // normalise the two supported input types into object form\n\n  if (typeof keyOrObj === 'object') updates = keyOrObj;\n  if (typeof keyOrObj === 'string') updates = (_updates = {}, _updates[keyOrObj] = maybeVal, _updates); // exit if we don't have an updates object at this point\n\n  if (!updates) return; // ensure a section with this name exists\n\n  if (!state[section]) state[section] = {}; // merge the updates with the existing section\n\n  state[section] = _$assign_11({}, state[section], updates);\n};\n\nvar get = function (state, section, key) {\n  if (typeof section !== 'string') return undefined;\n\n  if (!key) {\n    return state[section];\n  }\n\n  if (state[section]) {\n    return state[section][key];\n  }\n\n  return undefined;\n};\n\nvar clear = function (state, section, key) {\n  if (typeof section !== 'string') return; // clear an entire section\n\n  if (!key) {\n    delete state[section];\n    return;\n  } // clear a single value from a section\n\n\n  if (state[section]) {\n    delete state[section][key];\n  }\n};\n\nvar _$metadataDelegate_22 = {\n  add: __add_22,\n  get: get,\n  clear: clear\n};\n\nvar _$stackGenerator_33 = {};\n(function (root, factory) {\n  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n  /* istanbul ignore next */\n\n  if (typeof define === 'function' && define.amd) {\n    define('stack-generator', ['stackframe'], factory);\n  } else if (typeof _$stackGenerator_33 === 'object') {\n    _$stackGenerator_33 = factory(_$stackframe_34);\n  } else {\n    root.StackGenerator = factory(root.StackFrame);\n  }\n})(this, function (StackFrame) {\n  return {\n    backtrace: function StackGenerator$$backtrace(opts) {\n      var stack = [];\n      var maxStackSize = 10;\n\n      if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {\n        maxStackSize = opts.maxStackSize;\n      }\n\n      var curr = arguments.callee;\n\n      while (curr && stack.length < maxStackSize && curr['arguments']) {\n        // Allow V8 optimizations\n        var args = new Array(curr['arguments'].length);\n\n        for (var i = 0; i < args.length; ++i) {\n          args[i] = curr['arguments'][i];\n        }\n\n        if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n          stack.push(new StackFrame({\n            functionName: RegExp.$1 || undefined,\n            args: args\n          }));\n        } else {\n          stack.push(new StackFrame({\n            args: args\n          }));\n        }\n\n        try {\n          curr = curr.caller;\n        } catch (e) {\n          break;\n        }\n      }\n\n      return stack;\n    }\n  };\n});\n\n/* removed: var _$errorStackParser_10 = require('./lib/error-stack-parser'); */;\n\n/* removed: var _$stackGenerator_33 = require('stack-generator'); */;\n\n/* removed: var _$hasStack_19 = require('./lib/has-stack'); */;\n\n/* removed: var _$map_16 = require('./lib/es-utils/map'); */;\n\n/* removed: var _$reduce_17 = require('./lib/es-utils/reduce'); */;\n\n/* removed: var _$filter_12 = require('./lib/es-utils/filter'); */;\n\n/* removed: var _$assign_11 = require('./lib/es-utils/assign'); */;\n\n/* removed: var _$metadataDelegate_22 = require('./lib/metadata-delegate'); */;\n\n/* removed: var _$featureFlagDelegate_18 = require('./lib/feature-flag-delegate'); */;\n\n/* removed: var _$iserror_20 = require('./lib/iserror'); */;\n\nvar Event = /*#__PURE__*/function () {\n  function Event(errorClass, errorMessage, stacktrace, handledState, originalError) {\n    if (stacktrace === void 0) {\n      stacktrace = [];\n    }\n\n    if (handledState === void 0) {\n      handledState = defaultHandledState();\n    }\n\n    this.apiKey = undefined;\n    this.context = undefined;\n    this.groupingHash = undefined;\n    this.originalError = originalError;\n    this._handledState = handledState;\n    this.severity = this._handledState.severity;\n    this.unhandled = this._handledState.unhandled;\n    this.app = {};\n    this.device = {};\n    this.request = {};\n    this.breadcrumbs = [];\n    this.threads = [];\n    this._metadata = {};\n    this._features = {};\n    this._user = {};\n    this._session = undefined;\n    this.errors = [{\n      errorClass: ensureString(errorClass),\n      errorMessage: ensureString(errorMessage),\n      type: Event.__type,\n      stacktrace: _$reduce_17(stacktrace, function (accum, frame) {\n        var f = formatStackframe(frame); // don't include a stackframe if none of its properties are defined\n\n        try {\n          if (JSON.stringify(f) === '{}') return accum;\n          return accum.concat(f);\n        } catch (e) {\n          return accum;\n        }\n      }, [])\n    }]; // Flags.\n    // Note these are not initialised unless they are used\n    // to save unnecessary bytes in the browser bundle\n\n    /* this.attemptImmediateDelivery, default: true */\n  }\n\n  var _proto = Event.prototype;\n\n  _proto.addMetadata = function addMetadata(section, keyOrObj, maybeVal) {\n    return _$metadataDelegate_22.add(this._metadata, section, keyOrObj, maybeVal);\n  };\n\n  _proto.getMetadata = function getMetadata(section, key) {\n    return _$metadataDelegate_22.get(this._metadata, section, key);\n  };\n\n  _proto.clearMetadata = function clearMetadata(section, key) {\n    return _$metadataDelegate_22.clear(this._metadata, section, key);\n  };\n\n  _proto.addFeatureFlag = function addFeatureFlag(name, variant) {\n    if (variant === void 0) {\n      variant = null;\n    }\n\n    _$featureFlagDelegate_18.add(this._features, name, variant);\n  };\n\n  _proto.addFeatureFlags = function addFeatureFlags(featureFlags) {\n    _$featureFlagDelegate_18.merge(this._features, featureFlags);\n  };\n\n  _proto.clearFeatureFlag = function clearFeatureFlag(name) {\n    delete this._features[name];\n  };\n\n  _proto.clearFeatureFlags = function clearFeatureFlags() {\n    this._features = {};\n  };\n\n  _proto.getUser = function getUser() {\n    return this._user;\n  };\n\n  _proto.setUser = function setUser(id, email, name) {\n    this._user = {\n      id: id,\n      email: email,\n      name: name\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return {\n      payloadVersion: '4',\n      exceptions: _$map_16(this.errors, function (er) {\n        return _$assign_11({}, er, {\n          message: er.errorMessage\n        });\n      }),\n      severity: this.severity,\n      unhandled: this._handledState.unhandled,\n      severityReason: this._handledState.severityReason,\n      app: this.app,\n      device: this.device,\n      request: this.request,\n      breadcrumbs: this.breadcrumbs,\n      context: this.context,\n      groupingHash: this.groupingHash,\n      metaData: this._metadata,\n      user: this._user,\n      session: this._session,\n      featureFlags: _$featureFlagDelegate_18.toEventApi(this._features)\n    };\n  };\n\n  return Event;\n}(); // takes a stacktrace.js style stackframe (https://github.com/stacktracejs/stackframe)\n// and returns a Bugsnag compatible stackframe (https://docs.bugsnag.com/api/error-reporting/#json-payload)\n\n\nvar formatStackframe = function (frame) {\n  var f = {\n    file: frame.fileName,\n    method: normaliseFunctionName(frame.functionName),\n    lineNumber: frame.lineNumber,\n    columnNumber: frame.columnNumber,\n    code: undefined,\n    inProject: undefined\n  }; // Some instances result in no file:\n  // - calling notify() from chrome's terminal results in no file/method.\n  // - non-error exception thrown from global code in FF\n  // This adds one.\n\n  if (f.lineNumber > -1 && !f.file && !f.method) {\n    f.file = 'global code';\n  }\n\n  return f;\n};\n\nvar normaliseFunctionName = function (name) {\n  return /^global code$/i.test(name) ? 'global code' : name;\n};\n\nvar defaultHandledState = function () {\n  return {\n    unhandled: false,\n    severity: 'warning',\n    severityReason: {\n      type: 'handledException'\n    }\n  };\n};\n\nvar ensureString = function (str) {\n  return typeof str === 'string' ? str : '';\n}; // Helpers\n\n\nEvent.getStacktrace = function (error, errorFramesToSkip, backtraceFramesToSkip) {\n  if (_$hasStack_19(error)) return _$errorStackParser_10.parse(error).slice(errorFramesToSkip); // error wasn't provided or didn't have a stacktrace so try to walk the callstack\n\n  try {\n    return _$filter_12(_$stackGenerator_33.backtrace(), function (frame) {\n      return (frame.functionName || '').indexOf('StackGenerator$$') === -1;\n    }).slice(1 + backtraceFramesToSkip);\n  } catch (e) {\n    return [];\n  }\n};\n\nEvent.create = function (maybeError, tolerateNonErrors, handledState, component, errorFramesToSkip, logger) {\n  if (errorFramesToSkip === void 0) {\n    errorFramesToSkip = 0;\n  }\n\n  var _normaliseError = normaliseError(maybeError, tolerateNonErrors, component, logger),\n      error = _normaliseError[0],\n      internalFrames = _normaliseError[1];\n\n  var event;\n\n  try {\n    var stacktrace = Event.getStacktrace(error, // if an error was created/throw in the normaliseError() function, we need to\n    // tell the getStacktrace() function to skip the number of frames we know will\n    // be from our own functions. This is added to the number of frames deep we\n    // were told about\n    internalFrames > 0 ? 1 + internalFrames + errorFramesToSkip : 0, // if there's no stacktrace, the callstack may be walked to generated one.\n    // this is how many frames should be removed because they come from our library\n    1 + errorFramesToSkip);\n    event = new Event(error.name, error.message, stacktrace, handledState, maybeError);\n  } catch (e) {\n    event = new Event(error.name, error.message, [], handledState, maybeError);\n  }\n\n  if (error.name === 'InvalidError') {\n    event.addMetadata(\"\" + component, 'non-error parameter', makeSerialisable(maybeError));\n  }\n\n  return event;\n};\n\nvar makeSerialisable = function (err) {\n  if (err === null) return 'null';\n  if (err === undefined) return 'undefined';\n  return err;\n};\n\nvar normaliseError = function (maybeError, tolerateNonErrors, component, logger) {\n  var error;\n  var internalFrames = 0;\n\n  var createAndLogInputError = function (reason) {\n    if (logger) logger.warn(component + \" received a non-error: \\\"\" + reason + \"\\\"\");\n    var err = new Error(component + \" received a non-error. See \\\"\" + component + \"\\\" tab for more detail.\");\n    err.name = 'InvalidError';\n    return err;\n  }; // In some cases:\n  //\n  //  - the promise rejection handler (both in the browser and node)\n  //  - the node uncaughtException handler\n  //\n  // We are really limited in what we can do to get a stacktrace. So we use the\n  // tolerateNonErrors option to ensure that the resulting error communicates as\n  // such.\n\n\n  if (!tolerateNonErrors) {\n    if (_$iserror_20(maybeError)) {\n      error = maybeError;\n    } else {\n      error = createAndLogInputError(typeof maybeError);\n      internalFrames += 2;\n    }\n  } else {\n    switch (typeof maybeError) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n        error = new Error(String(maybeError));\n        internalFrames += 1;\n        break;\n\n      case 'function':\n        error = createAndLogInputError('function');\n        internalFrames += 2;\n        break;\n\n      case 'object':\n        if (maybeError !== null && _$iserror_20(maybeError)) {\n          error = maybeError;\n        } else if (maybeError !== null && hasNecessaryFields(maybeError)) {\n          error = new Error(maybeError.message || maybeError.errorMessage);\n          error.name = maybeError.name || maybeError.errorClass;\n          internalFrames += 1;\n        } else {\n          error = createAndLogInputError(maybeError === null ? 'null' : 'unsupported object');\n          internalFrames += 2;\n        }\n\n        break;\n\n      default:\n        error = createAndLogInputError('nothing');\n        internalFrames += 2;\n    }\n  }\n\n  if (!_$hasStack_19(error)) {\n    // in IE10/11 a new Error() doesn't have a stacktrace until you throw it, so try that here\n    try {\n      throw error;\n    } catch (e) {\n      if (_$hasStack_19(e)) {\n        error = e; // if the error only got a stacktrace after we threw it here, we know it\n        // will only have one extra internal frame from this function, regardless\n        // of whether it went through createAndLogInputError() or not\n\n        internalFrames = 1;\n      }\n    }\n  }\n\n  return [error, internalFrames];\n}; // default value for stacktrace.type\n\n\nEvent.__type = 'browserjs';\n\nvar hasNecessaryFields = function (error) {\n  return (typeof error.name === 'string' || typeof error.errorClass === 'string') && (typeof error.message === 'string' || typeof error.errorMessage === 'string');\n};\n\nvar _$Event_6 = Event;\n\n// This is a heavily modified/simplified version of\n//   https://github.com/othiym23/async-some\n// with the logic flipped so that it is akin to the\n// synchronous \"every\" method instead of \"some\".\n// run the asynchronous test function (fn) over each item in the array (arr)\n// in series until:\n//   - fn(item, cb) => calls cb(null, false)\n//   - or the end of the array is reached\n// the callback (cb) will be passed (null, false) if any of the items in arr\n// caused fn to call back with false, otherwise it will be passed (null, true)\nvar _$asyncEvery_7 = function (arr, fn, cb) {\n  var index = 0;\n\n  var next = function () {\n    if (index >= arr.length) return cb(null, true);\n    fn(arr[index], function (err, result) {\n      if (err) return cb(err);\n      if (result === false) return cb(null, false);\n      index++;\n      next();\n    });\n  };\n\n  next();\n};\n\n/* removed: var _$asyncEvery_7 = require('./async-every'); */;\n\nvar _$callbackRunner_9 = function (callbacks, event, onCallbackError, cb) {\n  // This function is how we support different kinds of callback:\n  //  - synchronous - return value\n  //  - node-style async with callback - cb(err, value)\n  //  - promise/thenable - resolve(value)\n  // It normalises each of these into the lowest common denominator – a node-style callback\n  var runMaybeAsyncCallback = function (fn, cb) {\n    if (typeof fn !== 'function') return cb(null);\n\n    try {\n      // if function appears sync…\n      if (fn.length !== 2) {\n        var ret = fn(event); // check if it returned a \"thenable\" (promise)\n\n        if (ret && typeof ret.then === 'function') {\n          return ret.then( // resolve\n          function (val) {\n            return setTimeout(function () {\n              return cb(null, val);\n            });\n          }, // reject\n          function (err) {\n            setTimeout(function () {\n              onCallbackError(err);\n              return cb(null, true);\n            });\n          });\n        }\n\n        return cb(null, ret);\n      } // if function is async…\n\n\n      fn(event, function (err, result) {\n        if (err) {\n          onCallbackError(err);\n          return cb(null);\n        }\n\n        cb(null, result);\n      });\n    } catch (e) {\n      onCallbackError(e);\n      cb(null);\n    }\n  };\n\n  _$asyncEvery_7(callbacks, runMaybeAsyncCallback, cb);\n};\n\nvar _$syncCallbackRunner_23 = function (callbacks, callbackArg, callbackType, logger) {\n  var ignore = false;\n  var cbs = callbacks.slice();\n\n  while (!ignore) {\n    if (!cbs.length) break;\n\n    try {\n      ignore = cbs.pop()(callbackArg) === false;\n    } catch (e) {\n      logger.error(\"Error occurred in \" + callbackType + \" callback, continuing anyway\\u2026\");\n      logger.error(e);\n    }\n  }\n\n  return ignore;\n};\n\nvar _$pad_29 = function pad(num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n\n/* removed: var _$pad_29 = require('./pad.js'); */;\n\nvar env = typeof window === 'object' ? window : self;\nvar globalCount = 0;\n\nfor (var prop in env) {\n  if (Object.hasOwnProperty.call(env, prop)) globalCount++;\n}\n\nvar mimeTypesLength = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar clientId = _$pad_29((mimeTypesLength + navigator.userAgent.length).toString(36) + globalCount.toString(36), 4);\n\nvar _$fingerprint_28 = function fingerprint() {\n  return clientId;\n};\n\n/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n/* removed: var _$fingerprint_28 = require('./lib/fingerprint.js'); */;\n\n/* removed: var _$pad_29 = require('./lib/pad.js'); */;\n\nvar c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize);\n\nfunction randomBlock() {\n  return _$pad_29((Math.random() * discreteValues << 0).toString(base), blockSize);\n}\n\nfunction safeCounter() {\n  c = c < discreteValues ? c : 0;\n  c++; // this is not subliminal\n\n  return c - 1;\n}\n\nfunction cuid() {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c',\n      // hard-coded allows for sequential access\n  // timestamp\n  // warning: this exposes the exact date and time\n  // that the uid was created.\n  timestamp = new Date().getTime().toString(base),\n      // Prevent same-machine collisions.\n  counter = _$pad_29(safeCounter().toString(base), blockSize),\n      // A few chars to generate distinct ids for different\n  // clients (so different computers are far less\n  // likely to generate the same id)\n  print = _$fingerprint_28(),\n      // Grab some more chars from Math.random()\n  random = randomBlock() + randomBlock();\n  return letter + timestamp + counter + print + random;\n}\n\ncuid.fingerprint = _$fingerprint_28;\nvar _$cuid_27 = cuid;\n\n/* removed: var _$cuid_27 = require('@bugsnag/cuid'); */;\n\nvar Session = /*#__PURE__*/function () {\n  function Session() {\n    this.id = _$cuid_27();\n    this.startedAt = new Date();\n    this._handled = 0;\n    this._unhandled = 0;\n    this._user = {};\n    this.app = {};\n    this.device = {};\n  }\n\n  var _proto = Session.prototype;\n\n  _proto.getUser = function getUser() {\n    return this._user;\n  };\n\n  _proto.setUser = function setUser(id, email, name) {\n    this._user = {\n      id: id,\n      email: email,\n      name: name\n    };\n  };\n\n  _proto.toJSON = function toJSON() {\n    return {\n      id: this.id,\n      startedAt: this.startedAt,\n      events: {\n        handled: this._handled,\n        unhandled: this._unhandled\n      }\n    };\n  };\n\n  _proto._track = function _track(event) {\n    this[event._handledState.unhandled ? '_unhandled' : '_handled'] += 1;\n  };\n\n  return Session;\n}();\n\nvar _$Session_35 = Session;\n\n/* removed: var _$config_5 = require('./config'); */;\n\n/* removed: var _$Event_6 = require('./event'); */;\n\n/* removed: var _$Breadcrumb_3 = require('./breadcrumb'); */;\n\n/* removed: var _$Session_35 = require('./session'); */;\n\n/* removed: var _$map_16 = require('./lib/es-utils/map'); */;\n\n/* removed: var _$includes_13 = require('./lib/es-utils/includes'); */;\n\n/* removed: var _$filter_12 = require('./lib/es-utils/filter'); */;\n\n/* removed: var _$reduce_17 = require('./lib/es-utils/reduce'); */;\n\n/* removed: var _$keys_15 = require('./lib/es-utils/keys'); */;\n\n/* removed: var _$assign_11 = require('./lib/es-utils/assign'); */;\n\n/* removed: var _$callbackRunner_9 = require('./lib/callback-runner'); */;\n\n/* removed: var _$featureFlagDelegate_18 = require('./lib/feature-flag-delegate'); */;\n\n/* removed: var _$metadataDelegate_22 = require('./lib/metadata-delegate'); */;\n\n/* removed: var _$syncCallbackRunner_23 = require('./lib/sync-callback-runner'); */;\n\n/* removed: var _$breadcrumbTypes_8 = require('./lib/breadcrumb-types'); */;\n\nvar noop = function () {};\n\nvar Client = /*#__PURE__*/function () {\n  function Client(configuration, schema, internalPlugins, notifier) {\n    var _this = this;\n\n    if (schema === void 0) {\n      schema = _$config_5.schema;\n    }\n\n    if (internalPlugins === void 0) {\n      internalPlugins = [];\n    }\n\n    // notifier id\n    this._notifier = notifier; // intialise opts and config\n\n    this._config = {};\n    this._schema = schema; // i/o\n\n    this._delivery = {\n      sendSession: noop,\n      sendEvent: noop\n    };\n    this._logger = {\n      debug: noop,\n      info: noop,\n      warn: noop,\n      error: noop\n    }; // plugins\n\n    this._plugins = {}; // state\n\n    this._breadcrumbs = [];\n    this._session = null;\n    this._metadata = {};\n    this._features = {};\n    this._context = undefined;\n    this._user = {}; // callbacks:\n    //  e: onError\n    //  s: onSession\n    //  sp: onSessionPayload\n    //  b: onBreadcrumb\n    // (note these names are minified by hand because object\n    // properties are not safe to minify automatically)\n\n    this._cbs = {\n      e: [],\n      s: [],\n      sp: [],\n      b: []\n    }; // expose internal constructors\n\n    this.Client = Client;\n    this.Event = _$Event_6;\n    this.Breadcrumb = _$Breadcrumb_3;\n    this.Session = _$Session_35;\n    this._config = this._configure(configuration, internalPlugins);\n    _$map_16(internalPlugins.concat(this._config.plugins), function (pl) {\n      if (pl) _this._loadPlugin(pl);\n    }); // when notify() is called we need to know how many frames are from our own source\n    // this inital value is 1 not 0 because we wrap notify() to ensure it is always\n    // bound to have the client as its `this` value – see below.\n\n    this._depth = 1;\n    var self = this;\n    var notify = this.notify;\n\n    this.notify = function () {\n      return notify.apply(self, arguments);\n    };\n  }\n\n  var _proto = Client.prototype;\n\n  _proto.addMetadata = function addMetadata(section, keyOrObj, maybeVal) {\n    return _$metadataDelegate_22.add(this._metadata, section, keyOrObj, maybeVal);\n  };\n\n  _proto.getMetadata = function getMetadata(section, key) {\n    return _$metadataDelegate_22.get(this._metadata, section, key);\n  };\n\n  _proto.clearMetadata = function clearMetadata(section, key) {\n    return _$metadataDelegate_22.clear(this._metadata, section, key);\n  };\n\n  _proto.addFeatureFlag = function addFeatureFlag(name, variant) {\n    if (variant === void 0) {\n      variant = null;\n    }\n\n    _$featureFlagDelegate_18.add(this._features, name, variant);\n  };\n\n  _proto.addFeatureFlags = function addFeatureFlags(featureFlags) {\n    _$featureFlagDelegate_18.merge(this._features, featureFlags);\n  };\n\n  _proto.clearFeatureFlag = function clearFeatureFlag(name) {\n    delete this._features[name];\n  };\n\n  _proto.clearFeatureFlags = function clearFeatureFlags() {\n    this._features = {};\n  };\n\n  _proto.getContext = function getContext() {\n    return this._context;\n  };\n\n  _proto.setContext = function setContext(c) {\n    this._context = c;\n  };\n\n  _proto._configure = function _configure(opts, internalPlugins) {\n    var schema = _$reduce_17(internalPlugins, function (schema, plugin) {\n      if (plugin && plugin.configSchema) return _$assign_11({}, schema, plugin.configSchema);\n      return schema;\n    }, this._schema); // accumulate configuration and error messages\n\n    var _reduce = _$reduce_17(_$keys_15(schema), function (accum, key) {\n      var defaultValue = schema[key].defaultValue(opts[key]);\n\n      if (opts[key] !== undefined) {\n        var valid = schema[key].validate(opts[key]);\n\n        if (!valid) {\n          accum.errors[key] = schema[key].message;\n          accum.config[key] = defaultValue;\n        } else {\n          if (schema[key].allowPartialObject) {\n            accum.config[key] = _$assign_11(defaultValue, opts[key]);\n          } else {\n            accum.config[key] = opts[key];\n          }\n        }\n      } else {\n        accum.config[key] = defaultValue;\n      }\n\n      return accum;\n    }, {\n      errors: {},\n      config: {}\n    }),\n        errors = _reduce.errors,\n        config = _reduce.config;\n\n    if (schema.apiKey) {\n      // missing api key is the only fatal error\n      if (!config.apiKey) throw new Error('No Bugsnag API Key set'); // warn about an apikey that is not of the expected format\n\n      if (!/^[0-9a-f]{32}$/i.test(config.apiKey)) errors.apiKey = 'should be a string of 32 hexadecimal characters';\n    } // update and elevate some options\n\n\n    this._metadata = _$assign_11({}, config.metadata);\n    _$featureFlagDelegate_18.merge(this._features, config.featureFlags);\n    this._user = _$assign_11({}, config.user);\n    this._context = config.context;\n    if (config.logger) this._logger = config.logger; // add callbacks\n\n    if (config.onError) this._cbs.e = this._cbs.e.concat(config.onError);\n    if (config.onBreadcrumb) this._cbs.b = this._cbs.b.concat(config.onBreadcrumb);\n    if (config.onSession) this._cbs.s = this._cbs.s.concat(config.onSession); // finally warn about any invalid config where we fell back to the default\n\n    if (_$keys_15(errors).length) {\n      this._logger.warn(generateConfigErrorMessage(errors, opts));\n    }\n\n    return config;\n  };\n\n  _proto.getUser = function getUser() {\n    return this._user;\n  };\n\n  _proto.setUser = function setUser(id, email, name) {\n    this._user = {\n      id: id,\n      email: email,\n      name: name\n    };\n  };\n\n  _proto._loadPlugin = function _loadPlugin(plugin) {\n    var result = plugin.load(this); // JS objects are not the safest way to store arbitrarily keyed values,\n    // so bookend the key with some characters that prevent tampering with\n    // stuff like __proto__ etc. (only store the result if the plugin had a\n    // name)\n\n    if (plugin.name) this._plugins[\"~\" + plugin.name + \"~\"] = result;\n    return this;\n  };\n\n  _proto.getPlugin = function getPlugin(name) {\n    return this._plugins[\"~\" + name + \"~\"];\n  };\n\n  _proto._setDelivery = function _setDelivery(d) {\n    this._delivery = d(this);\n  };\n\n  _proto.startSession = function startSession() {\n    var session = new _$Session_35();\n    session.app.releaseStage = this._config.releaseStage;\n    session.app.version = this._config.appVersion;\n    session.app.type = this._config.appType;\n    session._user = _$assign_11({}, this._user); // run onSession callbacks\n\n    var ignore = _$syncCallbackRunner_23(this._cbs.s, session, 'onSession', this._logger);\n\n    if (ignore) {\n      this._logger.debug('Session not started due to onSession callback');\n\n      return this;\n    }\n\n    return this._sessionDelegate.startSession(this, session);\n  };\n\n  _proto.addOnError = function addOnError(fn, front) {\n    if (front === void 0) {\n      front = false;\n    }\n\n    this._cbs.e[front ? 'unshift' : 'push'](fn);\n  };\n\n  _proto.removeOnError = function removeOnError(fn) {\n    this._cbs.e = _$filter_12(this._cbs.e, function (f) {\n      return f !== fn;\n    });\n  };\n\n  _proto._addOnSessionPayload = function _addOnSessionPayload(fn) {\n    this._cbs.sp.push(fn);\n  };\n\n  _proto.addOnSession = function addOnSession(fn) {\n    this._cbs.s.push(fn);\n  };\n\n  _proto.removeOnSession = function removeOnSession(fn) {\n    this._cbs.s = _$filter_12(this._cbs.s, function (f) {\n      return f !== fn;\n    });\n  };\n\n  _proto.addOnBreadcrumb = function addOnBreadcrumb(fn, front) {\n    if (front === void 0) {\n      front = false;\n    }\n\n    this._cbs.b[front ? 'unshift' : 'push'](fn);\n  };\n\n  _proto.removeOnBreadcrumb = function removeOnBreadcrumb(fn) {\n    this._cbs.b = _$filter_12(this._cbs.b, function (f) {\n      return f !== fn;\n    });\n  };\n\n  _proto.pauseSession = function pauseSession() {\n    return this._sessionDelegate.pauseSession(this);\n  };\n\n  _proto.resumeSession = function resumeSession() {\n    return this._sessionDelegate.resumeSession(this);\n  };\n\n  _proto.leaveBreadcrumb = function leaveBreadcrumb(message, metadata, type) {\n    // coerce bad values so that the defaults get set\n    message = typeof message === 'string' ? message : '';\n    type = typeof type === 'string' && _$includes_13(_$breadcrumbTypes_8, type) ? type : 'manual';\n    metadata = typeof metadata === 'object' && metadata !== null ? metadata : {}; // if no message, discard\n\n    if (!message) return;\n    var crumb = new _$Breadcrumb_3(message, metadata, type); // run onBreadcrumb callbacks\n\n    var ignore = _$syncCallbackRunner_23(this._cbs.b, crumb, 'onBreadcrumb', this._logger);\n\n    if (ignore) {\n      this._logger.debug('Breadcrumb not attached due to onBreadcrumb callback');\n\n      return;\n    } // push the valid crumb onto the queue and maintain the length\n\n\n    this._breadcrumbs.push(crumb);\n\n    if (this._breadcrumbs.length > this._config.maxBreadcrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(this._breadcrumbs.length - this._config.maxBreadcrumbs);\n    }\n  };\n\n  _proto._isBreadcrumbTypeEnabled = function _isBreadcrumbTypeEnabled(type) {\n    var types = this._config.enabledBreadcrumbTypes;\n    return types === null || _$includes_13(types, type);\n  };\n\n  _proto.notify = function notify(maybeError, onError, cb) {\n    if (cb === void 0) {\n      cb = noop;\n    }\n\n    var event = _$Event_6.create(maybeError, true, undefined, 'notify()', this._depth + 1, this._logger);\n\n    this._notify(event, onError, cb);\n  };\n\n  _proto._notify = function _notify(event, onError, cb) {\n    var _this2 = this;\n\n    if (cb === void 0) {\n      cb = noop;\n    }\n\n    event.app = _$assign_11({}, event.app, {\n      releaseStage: this._config.releaseStage,\n      version: this._config.appVersion,\n      type: this._config.appType\n    });\n    event.context = event.context || this._context;\n    event._metadata = _$assign_11({}, event._metadata, this._metadata);\n    event._features = _$assign_11({}, event._features, this._features);\n    event._user = _$assign_11({}, event._user, this._user);\n    event.breadcrumbs = this._breadcrumbs.slice(); // exit early if events should not be sent on the current releaseStage\n\n    if (this._config.enabledReleaseStages !== null && !_$includes_13(this._config.enabledReleaseStages, this._config.releaseStage)) {\n      this._logger.warn('Event not sent due to releaseStage/enabledReleaseStages configuration');\n\n      return cb(null, event);\n    }\n\n    var originalSeverity = event.severity;\n\n    var onCallbackError = function (err) {\n      // errors in callbacks are tolerated but we want to log them out\n      _this2._logger.error('Error occurred in onError callback, continuing anyway…');\n\n      _this2._logger.error(err);\n    };\n\n    var callbacks = [].concat(this._cbs.e).concat(onError);\n    _$callbackRunner_9(callbacks, event, onCallbackError, function (err, shouldSend) {\n      if (err) onCallbackError(err);\n\n      if (!shouldSend) {\n        _this2._logger.debug('Event not sent due to onError callback');\n\n        return cb(null, event);\n      }\n\n      if (_this2._isBreadcrumbTypeEnabled('error')) {\n        // only leave a crumb for the error if actually got sent\n        Client.prototype.leaveBreadcrumb.call(_this2, event.errors[0].errorClass, {\n          errorClass: event.errors[0].errorClass,\n          errorMessage: event.errors[0].errorMessage,\n          severity: event.severity\n        }, 'error');\n      }\n\n      if (originalSeverity !== event.severity) {\n        event._handledState.severityReason = {\n          type: 'userCallbackSetSeverity'\n        };\n      }\n\n      if (event.unhandled !== event._handledState.unhandled) {\n        event._handledState.severityReason.unhandledOverridden = true;\n        event._handledState.unhandled = event.unhandled;\n      }\n\n      if (_this2._session) {\n        _this2._session._track(event);\n\n        event._session = _this2._session;\n      }\n\n      _this2._delivery.sendEvent({\n        apiKey: event.apiKey || _this2._config.apiKey,\n        notifier: _this2._notifier,\n        events: [event]\n      }, function (err) {\n        return cb(err, event);\n      });\n    });\n  };\n\n  return Client;\n}();\n\nvar generateConfigErrorMessage = function (errors, rawInput) {\n  var er = new Error(\"Invalid configuration\\n\" + _$map_16(_$keys_15(errors), function (key) {\n    return \"  - \" + key + \" \" + errors[key] + \", got \" + stringify(rawInput[key]);\n  }).join('\\n\\n'));\n  return er;\n};\n\nvar stringify = function (val) {\n  switch (typeof val) {\n    case 'string':\n    case 'number':\n    case 'object':\n      return JSON.stringify(val);\n\n    default:\n      return String(val);\n  }\n};\n\nvar _$Client_4 = Client;\n\nvar _$jsonPayload_21 = {};\n/* removed: var _$safeJsonStringify_30 = require('@bugsnag/safe-json-stringify'); */;\n\nvar EVENT_REDACTION_PATHS = ['events.[].metaData', 'events.[].breadcrumbs.[].metaData', 'events.[].request'];\n\n_$jsonPayload_21.event = function (event, redactedKeys) {\n  var payload = _$safeJsonStringify_30(event, null, null, {\n    redactedPaths: EVENT_REDACTION_PATHS,\n    redactedKeys: redactedKeys\n  });\n\n  if (payload.length > 10e5) {\n    event.events[0]._metadata = {\n      notifier: \"WARNING!\\nSerialized payload was \" + payload.length / 10e5 + \"MB (limit = 1MB)\\nmetadata was removed\"\n    };\n    payload = _$safeJsonStringify_30(event, null, null, {\n      redactedPaths: EVENT_REDACTION_PATHS,\n      redactedKeys: redactedKeys\n    });\n    if (payload.length > 10e5) throw new Error('payload exceeded 1MB limit');\n  }\n\n  return payload;\n};\n\n_$jsonPayload_21.session = function (event, redactedKeys) {\n  var payload = _$safeJsonStringify_30(event, null, null);\n  if (payload.length > 10e5) throw new Error('payload exceeded 1MB limit');\n  return payload;\n};\n\nvar _$delivery_36 = {};\n/* removed: var _$jsonPayload_21 = require('@bugsnag/core/lib/json-payload'); */;\n\n_$delivery_36 = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    sendEvent: function (event, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      var url = getApiUrl(client._config, 'notify', '4', win);\n      var req = new win.XDomainRequest();\n\n      req.onload = function () {\n        cb(null);\n      };\n\n      req.open('POST', url);\n      setTimeout(function () {\n        try {\n          req.send(_$jsonPayload_21.event(event, client._config.redactedKeys));\n        } catch (e) {\n          client._logger.error(e);\n\n          cb(e);\n        }\n      }, 0);\n    },\n    sendSession: function (session, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      var url = getApiUrl(client._config, 'sessions', '1', win);\n      var req = new win.XDomainRequest();\n\n      req.onload = function () {\n        cb(null);\n      };\n\n      req.open('POST', url);\n      setTimeout(function () {\n        try {\n          req.send(_$jsonPayload_21.session(session, client._config.redactedKeys));\n        } catch (e) {\n          client._logger.error(e);\n\n          cb(e);\n        }\n      }, 0);\n    }\n  };\n};\n\nvar getApiUrl = function (config, endpoint, version, win) {\n  // IE8 doesn't support Date.prototype.toISOstring(), but it does convert a date\n  // to an ISO string when you use JSON stringify. Simply parsing the result of\n  // JSON.stringify is smaller than using a toISOstring() polyfill.\n  var isoDate = JSON.parse(JSON.stringify(new Date()));\n  var url = matchPageProtocol(config.endpoints[endpoint], win.location.protocol);\n  return url + \"?apiKey=\" + encodeURIComponent(config.apiKey) + \"&payloadVersion=\" + version + \"&sentAt=\" + encodeURIComponent(isoDate);\n};\n\nvar matchPageProtocol = _$delivery_36._matchPageProtocol = function (endpoint, pageProtocol) {\n  return pageProtocol === 'http:' ? endpoint.replace(/^https:/, 'http:') : endpoint;\n};\n\n/* removed: var _$jsonPayload_21 = require('@bugsnag/core/lib/json-payload'); */;\n\nvar _$delivery_37 = function (client, win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    sendEvent: function (event, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      try {\n        var url = client._config.endpoints.notify;\n        var req = new win.XMLHttpRequest();\n\n        req.onreadystatechange = function () {\n          if (req.readyState === win.XMLHttpRequest.DONE) cb(null);\n        };\n\n        req.open('POST', url);\n        req.setRequestHeader('Content-Type', 'application/json');\n        req.setRequestHeader('Bugsnag-Api-Key', event.apiKey || client._config.apiKey);\n        req.setRequestHeader('Bugsnag-Payload-Version', '4');\n        req.setRequestHeader('Bugsnag-Sent-At', new Date().toISOString());\n        req.send(_$jsonPayload_21.event(event, client._config.redactedKeys));\n      } catch (e) {\n        client._logger.error(e);\n      }\n    },\n    sendSession: function (session, cb) {\n      if (cb === void 0) {\n        cb = function () {};\n      }\n\n      try {\n        var url = client._config.endpoints.sessions;\n        var req = new win.XMLHttpRequest();\n\n        req.onreadystatechange = function () {\n          if (req.readyState === win.XMLHttpRequest.DONE) cb(null);\n        };\n\n        req.open('POST', url);\n        req.setRequestHeader('Content-Type', 'application/json');\n        req.setRequestHeader('Bugsnag-Api-Key', client._config.apiKey);\n        req.setRequestHeader('Bugsnag-Payload-Version', '1');\n        req.setRequestHeader('Bugsnag-Sent-At', new Date().toISOString());\n        req.send(_$jsonPayload_21.session(session, client._config.redactedKeys));\n      } catch (e) {\n        client._logger.error(e);\n      }\n    }\n  };\n};\n\nvar appStart = new Date();\n\nvar reset = function () {\n  appStart = new Date();\n};\n\nvar _$app_38 = {\n  name: 'appDuration',\n  load: function (client) {\n    client.addOnError(function (event) {\n      var now = new Date();\n      event.app.duration = now - appStart;\n    }, true);\n    return {\n      reset: reset\n    };\n  }\n};\n\n/*\n * Sets the default context to be the current URL\n */\nvar _$context_39 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    load: function (client) {\n      client.addOnError(function (event) {\n        if (event.context !== undefined) return;\n        event.context = win.location.pathname;\n      }, true);\n    }\n  };\n};\n\nvar _$pad_43 = function pad(num, size) {\n  var s = '000000000' + num;\n  return s.substr(s.length - size);\n};\n\n/* removed: var _$pad_43 = require('./pad.js'); */;\n\nvar __env_42 = typeof window === 'object' ? window : self;\nvar __globalCount_42 = 0;\n\nfor (var __prop_42 in __env_42) {\n  if (Object.hasOwnProperty.call(__env_42, __prop_42)) __globalCount_42++;\n}\n\nvar __mimeTypesLength_42 = navigator.mimeTypes ? navigator.mimeTypes.length : 0;\nvar __clientId_42 = _$pad_43((__mimeTypesLength_42 + navigator.userAgent.length).toString(36) + __globalCount_42.toString(36), 4);\n\nvar _$fingerprint_42 = function fingerprint() {\n  return __clientId_42;\n};\n\n/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n/* removed: var _$fingerprint_42 = require('./lib/fingerprint.js'); */;\n\n/* removed: var _$pad_43 = require('./lib/pad.js'); */;\n\nvar __c_41 = 0,\n    __blockSize_41 = 4,\n    __base_41 = 36,\n    __discreteValues_41 = Math.pow(__base_41, __blockSize_41);\n\nfunction __randomBlock_41() {\n  return _$pad_43((Math.random() * __discreteValues_41 << 0).toString(__base_41), __blockSize_41);\n}\n\nfunction __safeCounter_41() {\n  __c_41 = __c_41 < __discreteValues_41 ? __c_41 : 0;\n  __c_41++; // this is not subliminal\n\n  return __c_41 - 1;\n}\n\nfunction __cuid_41() {\n  // Starting with a lowercase letter makes\n  // it HTML element ID friendly.\n  var letter = 'c',\n      // hard-coded allows for sequential access\n  // timestamp\n  // warning: this exposes the exact date and time\n  // that the uid was created.\n  timestamp = new Date().getTime().toString(__base_41),\n      // Prevent same-machine collisions.\n  counter = _$pad_43(__safeCounter_41().toString(__base_41), __blockSize_41),\n      // A few chars to generate distinct ids for different\n  // clients (so different computers are far less\n  // likely to generate the same id)\n  print = _$fingerprint_42(),\n      // Grab some more chars from Math.random()\n  random = __randomBlock_41() + __randomBlock_41();\n  return letter + timestamp + counter + print + random;\n}\n\n__cuid_41.fingerprint = _$fingerprint_42;\nvar _$cuid_41 = __cuid_41;\n\n/* removed: var _$cuid_41 = require('@bugsnag/cuid'); */;\n\n/* removed: var _$assign_11 = require('@bugsnag/core/lib/es-utils/assign'); */;\n\nvar BUGSNAG_ANONYMOUS_ID_KEY = 'bugsnag-anonymous-id';\n\nvar getDeviceId = function () {\n  try {\n    var storage = window.localStorage;\n    var id = storage.getItem(BUGSNAG_ANONYMOUS_ID_KEY); // If we get an ID, make sure it looks like a valid cuid. The length can\n    // fluctuate slightly, so some leeway is built in\n\n    if (id && /^c[a-z0-9]{20,32}$/.test(id)) {\n      return id;\n    }\n\n    id = _$cuid_41();\n    storage.setItem(BUGSNAG_ANONYMOUS_ID_KEY, id);\n    return id;\n  } catch (err) {// If localStorage is not available (e.g. because it's disabled) then give up\n  }\n};\n/*\n * Automatically detects browser device details\n */\n\n\nvar _$device_40 = function (nav, screen) {\n  if (nav === void 0) {\n    nav = navigator;\n  }\n\n  if (screen === void 0) {\n    screen = window.screen;\n  }\n\n  return {\n    load: function (client) {\n      var device = {\n        locale: nav.browserLanguage || nav.systemLanguage || nav.userLanguage || nav.language,\n        userAgent: nav.userAgent\n      };\n\n      if (screen && screen.orientation && screen.orientation.type) {\n        device.orientation = screen.orientation.type;\n      } else {\n        device.orientation = document.documentElement.clientWidth > document.documentElement.clientHeight ? 'landscape' : 'portrait';\n      }\n\n      if (client._config.generateAnonymousId) {\n        device.id = getDeviceId();\n      }\n\n      client.addOnSession(function (session) {\n        session.device = _$assign_11({}, session.device, device); // only set device id if collectUserIp is false\n\n        if (!client._config.collectUserIp) setDefaultUserId(session);\n      }); // add time just as the event is sent\n\n      client.addOnError(function (event) {\n        event.device = _$assign_11({}, event.device, device, {\n          time: new Date()\n        });\n        if (!client._config.collectUserIp) setDefaultUserId(event);\n      }, true);\n    },\n    configSchema: {\n      generateAnonymousId: {\n        validate: function (value) {\n          return value === true || value === false;\n        },\n        defaultValue: function () {\n          return true;\n        },\n        message: 'should be true|false'\n      }\n    }\n  };\n};\n\nvar setDefaultUserId = function (eventOrSession) {\n  // device id is also used to populate the user id field, if it's not already set\n  var user = eventOrSession.getUser();\n\n  if (!user || !user.id) {\n    eventOrSession.setUser(eventOrSession.device.id);\n  }\n};\n\n/* removed: var _$assign_11 = require('@bugsnag/core/lib/es-utils/assign'); */;\n/*\n * Sets the event request: { url } to be the current href\n */\n\n\nvar _$request_44 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    load: function (client) {\n      client.addOnError(function (event) {\n        if (event.request && event.request.url) return;\n        event.request = _$assign_11({}, event.request, {\n          url: win.location.href\n        });\n      }, true);\n    }\n  };\n};\n\n/* removed: var _$includes_13 = require('@bugsnag/core/lib/es-utils/includes'); */;\n\nvar _$session_45 = {\n  load: function (client) {\n    client._sessionDelegate = sessionDelegate;\n  }\n};\nvar sessionDelegate = {\n  startSession: function (client, session) {\n    var sessionClient = client;\n    sessionClient._session = session;\n    sessionClient._pausedSession = null; // exit early if the current releaseStage is not enabled\n\n    if (sessionClient._config.enabledReleaseStages !== null && !_$includes_13(sessionClient._config.enabledReleaseStages, sessionClient._config.releaseStage)) {\n      sessionClient._logger.warn('Session not sent due to releaseStage/enabledReleaseStages configuration');\n\n      return sessionClient;\n    }\n\n    sessionClient._delivery.sendSession({\n      notifier: sessionClient._notifier,\n      device: session.device,\n      app: session.app,\n      sessions: [{\n        id: session.id,\n        startedAt: session.startedAt,\n        user: session._user\n      }]\n    });\n\n    return sessionClient;\n  },\n  resumeSession: function (client) {\n    // Do nothing if there's already an active session\n    if (client._session) {\n      return client;\n    } // If we have a paused session then make it the active session\n\n\n    if (client._pausedSession) {\n      client._session = client._pausedSession;\n      client._pausedSession = null;\n      return client;\n    } // Otherwise start a new session\n\n\n    return client.startSession();\n  },\n  pauseSession: function (client) {\n    client._pausedSession = client._session;\n    client._session = null;\n  }\n};\n\n/* removed: var _$assign_11 = require('@bugsnag/core/lib/es-utils/assign'); */;\n/*\n * Prevent collection of user IPs\n */\n\n\nvar _$clientIp_46 = {\n  load: function (client) {\n    if (client._config.collectUserIp) return;\n    client.addOnError(function (event) {\n      // If user.id is explicitly undefined, it will be missing from the payload. It needs\n      // removing so that the following line replaces it\n      if (event._user && typeof event._user.id === 'undefined') delete event._user.id;\n      event._user = _$assign_11({\n        id: '[REDACTED]'\n      }, event._user);\n      event.request = _$assign_11({\n        clientIp: '[REDACTED]'\n      }, event.request);\n    });\n  },\n  configSchema: {\n    collectUserIp: {\n      defaultValue: function () {\n        return true;\n      },\n      message: 'should be true|false',\n      validate: function (value) {\n        return value === true || value === false;\n      }\n    }\n  }\n};\n\nvar _$consoleBreadcrumbs_47 = {};\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$reduce_17 = require('@bugsnag/core/lib/es-utils/reduce'); */;\n\n/* removed: var _$filter_12 = require('@bugsnag/core/lib/es-utils/filter'); */;\n/*\n * Leaves breadcrumbs when console log methods are called\n */\n\n\n_$consoleBreadcrumbs_47.load = function (client) {\n  var isDev = /^(local-)?dev(elopment)?$/.test(client._config.releaseStage);\n  if (isDev || !client._isBreadcrumbTypeEnabled('log')) return;\n  _$map_16(CONSOLE_LOG_METHODS, function (method) {\n    var original = console[method];\n\n    console[method] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      client.leaveBreadcrumb('Console output', _$reduce_17(args, function (accum, arg, i) {\n        // do the best/simplest stringification of each argument\n        var stringified = '[Unknown value]'; // this may fail if the input is:\n        // - an object whose [[Prototype]] is null (no toString)\n        // - an object with a broken toString or @@toPrimitive implementation\n\n        try {\n          stringified = String(arg);\n        } catch (e) {} // if it stringifies to [object Object] attempt to JSON stringify\n\n\n        if (stringified === '[object Object]') {\n          // catch stringify errors and fallback to [object Object]\n          try {\n            stringified = JSON.stringify(arg);\n          } catch (e) {}\n        }\n\n        accum[\"[\" + i + \"]\"] = stringified;\n        return accum;\n      }, {\n        severity: method.indexOf('group') === 0 ? 'log' : method\n      }), 'log');\n      original.apply(console, args);\n    };\n\n    console[method]._restore = function () {\n      console[method] = original;\n    };\n  });\n};\n\nif (false) {}\n\nvar CONSOLE_LOG_METHODS = _$filter_12(['log', 'debug', 'info', 'warn', 'error'], function (method) {\n  return typeof console !== 'undefined' && typeof console[method] === 'function';\n});\n\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$reduce_17 = require('@bugsnag/core/lib/es-utils/reduce'); */;\n\n/* removed: var _$filter_12 = require('@bugsnag/core/lib/es-utils/filter'); */;\n\nvar MAX_LINE_LENGTH = 200;\nvar MAX_SCRIPT_LENGTH = 500000;\n\nvar _$inlineScriptContent_48 = function (doc, win) {\n  if (doc === void 0) {\n    doc = document;\n  }\n\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    load: function (client) {\n      if (!client._config.trackInlineScripts) return;\n      var originalLocation = win.location.href;\n      var html = ''; // in IE8-10 the 'interactive' state can fire too soon (before scripts have finished executing), so in those\n      // we wait for the 'complete' state before assuming that synchronous scripts are no longer executing\n\n      var isOldIe = !!doc.attachEvent;\n      var DOMContentLoaded = isOldIe ? doc.readyState === 'complete' : doc.readyState !== 'loading';\n\n      var getHtml = function () {\n        return doc.documentElement.outerHTML;\n      }; // get whatever HTML exists at this point in time\n\n\n      html = getHtml();\n      var prev = doc.onreadystatechange; // then update it when the DOM content has loaded\n\n      doc.onreadystatechange = function () {\n        // IE8 compatible alternative to document#DOMContentLoaded\n        if (doc.readyState === 'interactive') {\n          html = getHtml();\n          DOMContentLoaded = true;\n        }\n\n        try {\n          prev.apply(this, arguments);\n        } catch (e) {}\n      };\n\n      var _lastScript = null;\n\n      var updateLastScript = function (script) {\n        _lastScript = script;\n      };\n\n      var getCurrentScript = function () {\n        var script = doc.currentScript || _lastScript;\n\n        if (!script && !DOMContentLoaded) {\n          var scripts = doc.scripts || doc.getElementsByTagName('script');\n          script = scripts[scripts.length - 1];\n        }\n\n        return script;\n      };\n\n      var addSurroundingCode = function (lineNumber) {\n        // get whatever html has rendered at this point\n        if (!DOMContentLoaded || !html) html = getHtml(); // simulate the raw html\n\n        var htmlLines = ['\x3c!-- DOC START --\x3e'].concat(html.split('\\n'));\n        var zeroBasedLine = lineNumber - 1;\n        var start = Math.max(zeroBasedLine - 3, 0);\n        var end = Math.min(zeroBasedLine + 3, htmlLines.length);\n        return _$reduce_17(htmlLines.slice(start, end), function (accum, line, i) {\n          accum[start + 1 + i] = line.length <= MAX_LINE_LENGTH ? line : line.substr(0, MAX_LINE_LENGTH);\n          return accum;\n        }, {});\n      };\n\n      client.addOnError(function (event) {\n        // remove any of our own frames that may be part the stack this\n        // happens before the inline script check as it happens for all errors\n        event.errors[0].stacktrace = _$filter_12(event.errors[0].stacktrace, function (f) {\n          return !/__trace__$/.test(f.method);\n        });\n        var frame = event.errors[0].stacktrace[0]; // if frame.file exists and is not the original location of the page, this can't be an inline script\n\n        if (frame && frame.file && frame.file.replace(/#.*$/, '') !== originalLocation.replace(/#.*$/, '')) return; // grab the last script known to have run\n\n        var currentScript = getCurrentScript();\n\n        if (currentScript) {\n          var content = currentScript.innerHTML;\n          event.addMetadata('script', 'content', content.length <= MAX_SCRIPT_LENGTH ? content : content.substr(0, MAX_SCRIPT_LENGTH)); // only attempt to grab some surrounding code if we have a line number\n\n          if (frame && frame.lineNumber) {\n            frame.code = addSurroundingCode(frame.lineNumber);\n          }\n        }\n      }, true); // Proxy all the timer functions whose callback is their 0th argument.\n      // Keep a reference to the original setTimeout because we need it later\n\n      var _map = _$map_16(['setTimeout', 'setInterval', 'setImmediate', 'requestAnimationFrame'], function (fn) {\n        return __proxy(win, fn, function (original) {\n          return __traceOriginalScript(original, function (args) {\n            return {\n              get: function () {\n                return args[0];\n              },\n              replace: function (fn) {\n                args[0] = fn;\n              }\n            };\n          });\n        });\n      }),\n          _setTimeout = _map[0]; // Proxy all the host objects whose prototypes have an addEventListener function\n\n\n      _$map_16(['EventTarget', 'Window', 'Node', 'ApplicationCache', 'AudioTrackList', 'ChannelMergerNode', 'CryptoOperation', 'EventSource', 'FileReader', 'HTMLUnknownElement', 'IDBDatabase', 'IDBRequest', 'IDBTransaction', 'KeyOperation', 'MediaController', 'MessagePort', 'ModalWindow', 'Notification', 'SVGElementInstance', 'Screen', 'TextTrack', 'TextTrackCue', 'TextTrackList', 'WebSocket', 'WebSocketWorker', 'Worker', 'XMLHttpRequest', 'XMLHttpRequestEventTarget', 'XMLHttpRequestUpload'], function (o) {\n        if (!win[o] || !win[o].prototype || !Object.prototype.hasOwnProperty.call(win[o].prototype, 'addEventListener')) return;\n\n        __proxy(win[o].prototype, 'addEventListener', function (original) {\n          return __traceOriginalScript(original, eventTargetCallbackAccessor);\n        });\n\n        __proxy(win[o].prototype, 'removeEventListener', function (original) {\n          return __traceOriginalScript(original, eventTargetCallbackAccessor, true);\n        });\n      });\n\n      function __traceOriginalScript(fn, callbackAccessor, alsoCallOriginal) {\n        if (alsoCallOriginal === void 0) {\n          alsoCallOriginal = false;\n        }\n\n        return function () {\n          // this is required for removeEventListener to remove anything added with\n          // addEventListener before the functions started being wrapped by Bugsnag\n          var args = [].slice.call(arguments);\n\n          try {\n            var cba = callbackAccessor(args);\n            var cb = cba.get();\n            if (alsoCallOriginal) fn.apply(this, args);\n            if (typeof cb !== 'function') return fn.apply(this, args);\n\n            if (cb.__trace__) {\n              cba.replace(cb.__trace__);\n            } else {\n              var script = getCurrentScript(); // this function mustn't be annonymous due to a bug in the stack\n              // generation logic, meaning it gets tripped up\n              // see: https://github.com/stacktracejs/stack-generator/issues/6\n\n              cb.__trace__ = function __trace__() {\n                // set the script that called this function\n                updateLastScript(script); // immediately unset the currentScript synchronously below, however\n                // if this cb throws an error the line after will not get run so schedule\n                // an almost-immediate aysnc update too\n\n                _setTimeout(function () {\n                  updateLastScript(null);\n                }, 0);\n\n                var ret = cb.apply(this, arguments);\n                updateLastScript(null);\n                return ret;\n              };\n\n              cb.__trace__.__trace__ = cb.__trace__;\n              cba.replace(cb.__trace__);\n            }\n          } catch (e) {// swallow these errors on Selenium:\n            // Permission denied to access property '__trace__'\n            // WebDriverException: Message: Permission denied to access property \"handleEvent\"\n          } // IE8 doesn't let you call .apply() on setTimeout/setInterval\n\n\n          if (fn.apply) return fn.apply(this, args);\n\n          switch (args.length) {\n            case 1:\n              return fn(args[0]);\n\n            case 2:\n              return fn(args[0], args[1]);\n\n            default:\n              return fn();\n          }\n        };\n      }\n    },\n    configSchema: {\n      trackInlineScripts: {\n        validate: function (value) {\n          return value === true || value === false;\n        },\n        defaultValue: function () {\n          return true;\n        },\n        message: 'should be true|false'\n      }\n    }\n  };\n};\n\nfunction __proxy(host, name, replacer) {\n  var original = host[name];\n  if (!original) return original;\n  var replacement = replacer(original);\n  host[name] = replacement;\n  return original;\n}\n\nfunction eventTargetCallbackAccessor(args) {\n  var isEventHandlerObj = !!args[1] && typeof args[1].handleEvent === 'function';\n  return {\n    get: function () {\n      return isEventHandlerObj ? args[1].handleEvent : args[1];\n    },\n    replace: function (fn) {\n      if (isEventHandlerObj) {\n        args[1].handleEvent = fn;\n      } else {\n        args[1] = fn;\n      }\n    }\n  };\n}\n\n/*\n * Leaves breadcrumbs when the user interacts with the DOM\n */\nvar _$interactionBreadcrumbs_49 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    load: function (client) {\n      if (!('addEventListener' in win)) return;\n      if (!client._isBreadcrumbTypeEnabled('user')) return;\n      win.addEventListener('click', function (event) {\n        var targetText, targetSelector;\n\n        try {\n          targetText = getNodeText(event.target);\n          targetSelector = getNodeSelector(event.target, win);\n        } catch (e) {\n          targetText = '[hidden]';\n          targetSelector = '[hidden]';\n\n          client._logger.error('Cross domain error when tracking click event. See docs: https://tinyurl.com/yy3rn63z');\n        }\n\n        client.leaveBreadcrumb('UI click', {\n          targetText: targetText,\n          targetSelector: targetSelector\n        }, 'user');\n      }, true);\n    }\n  };\n}; // extract text content from a element\n\n\nvar getNodeText = function (el) {\n  var text = el.textContent || el.innerText || '';\n  if (!text && (el.type === 'submit' || el.type === 'button')) text = el.value;\n  text = text.replace(/^\\s+|\\s+$/g, ''); // trim whitespace\n\n  return truncate(text, 140);\n}; // Create a label from tagname, id and css class of the element\n\n\nfunction getNodeSelector(el, win) {\n  var parts = [el.tagName];\n  if (el.id) parts.push('#' + el.id);\n  if (el.className && el.className.length) parts.push(\".\" + el.className.split(' ').join('.')); // Can't get much more advanced with the current browser\n\n  if (!win.document.querySelectorAll || !Array.prototype.indexOf) return parts.join('');\n\n  try {\n    if (win.document.querySelectorAll(parts.join('')).length === 1) return parts.join('');\n  } catch (e) {\n    // Sometimes the query selector can be invalid just return it as-is\n    return parts.join('');\n  } // try to get a more specific selector if this one matches more than one element\n\n\n  if (el.parentNode.childNodes.length > 1) {\n    var index = Array.prototype.indexOf.call(el.parentNode.childNodes, el) + 1;\n    parts.push(\":nth-child(\" + index + \")\");\n  }\n\n  if (win.document.querySelectorAll(parts.join('')).length === 1) return parts.join(''); // try prepending the parent node selector\n\n  if (el.parentNode) return getNodeSelector(el.parentNode, win) + \" > \" + parts.join('');\n  return parts.join('');\n}\n\nfunction truncate(value, length) {\n  var ommision = '(...)';\n  if (value && value.length <= length) return value;\n  return value.slice(0, length - ommision.length) + ommision;\n}\n\nvar _$navigationBreadcrumbs_50 = {};\n/*\n* Leaves breadcrumbs when navigation methods are called or events are emitted\n*/\n_$navigationBreadcrumbs_50 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var plugin = {\n    load: function (client) {\n      if (!('addEventListener' in win)) return;\n      if (!client._isBreadcrumbTypeEnabled('navigation')) return; // returns a function that will drop a breadcrumb with a given name\n\n      var drop = function (name) {\n        return function () {\n          return client.leaveBreadcrumb(name, {}, 'navigation');\n        };\n      }; // simple drops – just names, no meta\n\n\n      win.addEventListener('pagehide', drop('Page hidden'), true);\n      win.addEventListener('pageshow', drop('Page shown'), true);\n      win.addEventListener('load', drop('Page loaded'), true);\n      win.document.addEventListener('DOMContentLoaded', drop('DOMContentLoaded'), true); // some browsers like to emit popstate when the page loads, so only add the popstate listener after that\n\n      win.addEventListener('load', function () {\n        return win.addEventListener('popstate', drop('Navigated back'), true);\n      }); // hashchange has some metadata that we care about\n\n      win.addEventListener('hashchange', function (event) {\n        var metadata = event.oldURL ? {\n          from: relativeLocation(event.oldURL, win),\n          to: relativeLocation(event.newURL, win),\n          state: getCurrentState(win)\n        } : {\n          to: relativeLocation(win.location.href, win)\n        };\n        client.leaveBreadcrumb('Hash changed', metadata, 'navigation');\n      }, true); // the only way to know about replaceState/pushState is to wrap them… >_<\n\n      if (win.history.replaceState) wrapHistoryFn(client, win.history, 'replaceState', win);\n      if (win.history.pushState) wrapHistoryFn(client, win.history, 'pushState', win);\n    }\n  };\n\n  if (false) {}\n\n  return plugin;\n};\n\nif (false) {} // takes a full url like http://foo.com:1234/pages/01.html?yes=no#section-2 and returns\n// just the path and hash parts, e.g. /pages/01.html?yes=no#section-2\n\n\nvar relativeLocation = function (url, win) {\n  var a = win.document.createElement('A');\n  a.href = url;\n  return \"\" + a.pathname + a.search + a.hash;\n};\n\nvar stateChangeToMetadata = function (win, state, title, url) {\n  var currentPath = relativeLocation(win.location.href, win);\n  return {\n    title: title,\n    state: state,\n    prevState: getCurrentState(win),\n    to: url || currentPath,\n    from: currentPath\n  };\n};\n\nvar wrapHistoryFn = function (client, target, fn, win) {\n  var orig = target[fn];\n\n  target[fn] = function (state, title, url) {\n    client.leaveBreadcrumb(\"History \" + fn, stateChangeToMetadata(win, state, title, url), 'navigation'); // if throttle plugin is in use, reset the event sent count\n\n    if (typeof client.resetEventCount === 'function') client.resetEventCount(); // if the client is operating in auto session-mode, a new route should trigger a new session\n\n    if (client._config.autoTrackSessions) client.startSession(); // Internet Explorer will convert `undefined` to a string when passed, causing an unintended redirect\n    // to '/undefined'. therefore we only pass the url if it's not undefined.\n\n    orig.apply(target, [state, title].concat(url !== undefined ? url : []));\n  };\n\n  if (false) {}\n};\n\nvar getCurrentState = function (win) {\n  try {\n    return win.history.state;\n  } catch (e) {}\n};\n\nvar BREADCRUMB_TYPE = 'request'; // keys to safely store metadata on the request object\n\nvar REQUEST_SETUP_KEY = 'BS~~S';\nvar REQUEST_URL_KEY = 'BS~~U';\nvar REQUEST_METHOD_KEY = 'BS~~M';\n\n/* removed: var _$includes_13 = require('@bugsnag/core/lib/es-utils/includes'); */;\n/*\n * Leaves breadcrumbs when network requests occur\n */\n\n\nvar _$networkBreadcrumbs_51 = function (_ignoredUrls, win) {\n  if (_ignoredUrls === void 0) {\n    _ignoredUrls = [];\n  }\n\n  if (win === void 0) {\n    win = window;\n  }\n\n  var restoreFunctions = [];\n  var plugin = {\n    load: function (client) {\n      if (!client._isBreadcrumbTypeEnabled('request')) return;\n      var ignoredUrls = [client._config.endpoints.notify, client._config.endpoints.sessions].concat(_ignoredUrls);\n      monkeyPatchXMLHttpRequest();\n      monkeyPatchFetch(); // XMLHttpRequest monkey patch\n\n      function monkeyPatchXMLHttpRequest() {\n        if (!('addEventListener' in win.XMLHttpRequest.prototype)) return;\n        var nativeOpen = win.XMLHttpRequest.prototype.open; // override native open()\n\n        win.XMLHttpRequest.prototype.open = function open(method, url) {\n          // store url and HTTP method for later\n          this[REQUEST_URL_KEY] = url;\n          this[REQUEST_METHOD_KEY] = method; // if we have already setup listeners, it means open() was called twice, we need to remove\n          // the listeners and recreate them\n\n          if (this[REQUEST_SETUP_KEY]) {\n            this.removeEventListener('load', handleXHRLoad);\n            this.removeEventListener('error', handleXHRError);\n          } // attach load event listener\n\n\n          this.addEventListener('load', handleXHRLoad); // attach error event listener\n\n          this.addEventListener('error', handleXHRError);\n          this[REQUEST_SETUP_KEY] = true;\n          nativeOpen.apply(this, arguments);\n        };\n\n        if (false) {}\n      }\n\n      function handleXHRLoad() {\n        var url = this[REQUEST_URL_KEY];\n\n        if (url === undefined) {\n          client._logger.warn('The request URL is no longer present on this XMLHttpRequest. A breadcrumb cannot be left for this request.');\n\n          return;\n        } // an XMLHttpRequest's URL can be an object as long as its 'toString'\n        // returns a URL, e.g. a HTMLAnchorElement\n\n\n        if (typeof url === 'string' && _$includes_13(ignoredUrls, url.replace(/\\?.*$/, ''))) {\n          // don't leave a network breadcrumb from bugsnag notify calls\n          return;\n        }\n\n        var metadata = {\n          status: this.status,\n          request: this[REQUEST_METHOD_KEY] + \" \" + this[REQUEST_URL_KEY]\n        };\n\n        if (this.status >= 400) {\n          // contacted server but got an error response\n          client.leaveBreadcrumb('XMLHttpRequest failed', metadata, BREADCRUMB_TYPE);\n        } else {\n          client.leaveBreadcrumb('XMLHttpRequest succeeded', metadata, BREADCRUMB_TYPE);\n        }\n      }\n\n      function handleXHRError() {\n        var url = this[REQUEST_URL_KEY];\n\n        if (url === undefined) {\n          client._logger.warn('The request URL is no longer present on this XMLHttpRequest. A breadcrumb cannot be left for this request.');\n\n          return;\n        }\n\n        if (typeof url === 'string' && _$includes_13(ignoredUrls, url.replace(/\\?.*$/, ''))) {\n          // don't leave a network breadcrumb from bugsnag notify calls\n          return;\n        } // failed to contact server\n\n\n        client.leaveBreadcrumb('XMLHttpRequest error', {\n          request: this[REQUEST_METHOD_KEY] + \" \" + this[REQUEST_URL_KEY]\n        }, BREADCRUMB_TYPE);\n      } // window.fetch monkey patch\n\n\n      function monkeyPatchFetch() {\n        // only patch it if it exists and if it is not a polyfill (patching a polyfilled\n        // fetch() results in duplicate breadcrumbs for the same request because the\n        // implementation uses XMLHttpRequest which is also patched)\n        if (!('fetch' in win) || win.fetch.polyfill) return;\n        var oldFetch = win.fetch;\n\n        win.fetch = function fetch() {\n          var _arguments = arguments;\n          var urlOrRequest = arguments[0];\n          var options = arguments[1];\n          var method;\n          var url = null;\n\n          if (urlOrRequest && typeof urlOrRequest === 'object') {\n            url = urlOrRequest.url;\n\n            if (options && 'method' in options) {\n              method = options.method;\n            } else if (urlOrRequest && 'method' in urlOrRequest) {\n              method = urlOrRequest.method;\n            }\n          } else {\n            url = urlOrRequest;\n\n            if (options && 'method' in options) {\n              method = options.method;\n            }\n          }\n\n          if (method === undefined) {\n            method = 'GET';\n          }\n\n          return new Promise(function (resolve, reject) {\n            // pass through to native fetch\n            oldFetch.apply(void 0, _arguments).then(function (response) {\n              handleFetchSuccess(response, method, url);\n              resolve(response);\n            })[\"catch\"](function (error) {\n              handleFetchError(method, url);\n              reject(error);\n            });\n          });\n        };\n\n        if (false) {}\n      }\n\n      var handleFetchSuccess = function (response, method, url) {\n        var metadata = {\n          status: response.status,\n          request: method + \" \" + url\n        };\n\n        if (response.status >= 400) {\n          // when the request comes back with a 4xx or 5xx status it does not reject the fetch promise,\n          client.leaveBreadcrumb('fetch() failed', metadata, BREADCRUMB_TYPE);\n        } else {\n          client.leaveBreadcrumb('fetch() succeeded', metadata, BREADCRUMB_TYPE);\n        }\n      };\n\n      var handleFetchError = function (method, url) {\n        client.leaveBreadcrumb('fetch() error', {\n          request: method + \" \" + url\n        }, BREADCRUMB_TYPE);\n      };\n    }\n  };\n\n  if (false) {}\n\n  return plugin;\n};\n\n/* removed: var _$intRange_24 = require('@bugsnag/core/lib/validators/int-range'); */;\n/*\n * Throttles and dedupes events\n */\n\n\nvar _$throttle_52 = {\n  load: function (client) {\n    // track sent events for each init of the plugin\n    var n = 0; // add onError hook\n\n    client.addOnError(function (event) {\n      // have max events been sent already?\n      if (n >= client._config.maxEvents) return false;\n      n++;\n    });\n\n    client.resetEventCount = function () {\n      n = 0;\n    };\n  },\n  configSchema: {\n    maxEvents: {\n      defaultValue: function () {\n        return 10;\n      },\n      message: 'should be a positive integer ≤100',\n      validate: function (val) {\n        return _$intRange_24(1, 100)(val);\n      }\n    }\n  }\n};\n\nvar _$stripQueryString_53 = {};\n/*\n * Remove query strings (and fragments) from stacktraces\n */\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$reduce_17 = require('@bugsnag/core/lib/es-utils/reduce'); */;\n\n_$stripQueryString_53 = {\n  load: function (client) {\n    client.addOnError(function (event) {\n      var allFrames = _$reduce_17(event.errors, function (accum, er) {\n        return accum.concat(er.stacktrace);\n      }, []);\n      _$map_16(allFrames, function (frame) {\n        frame.file = strip(frame.file);\n      });\n    });\n  }\n};\n\nvar strip = _$stripQueryString_53._strip = function (str) {\n  return typeof str === 'string' ? str.replace(/\\?.*$/, '').replace(/#.*$/, '') : str;\n};\n\n/*\n * Automatically notifies Bugsnag when window.onerror is called\n */\nvar _$onerror_54 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return {\n    load: function (client) {\n      if (!client._config.autoDetectErrors) return;\n      if (!client._config.enabledErrorTypes.unhandledExceptions) return;\n\n      function onerror(messageOrEvent, url, lineNo, charNo, error) {\n        // Ignore errors with no info due to CORS settings\n        if (lineNo === 0 && /Script error\\.?/.test(messageOrEvent)) {\n          client._logger.warn('Ignoring cross-domain or eval script error. See docs: https://tinyurl.com/yy3rn63z');\n        } else {\n          // any error sent to window.onerror is unhandled and has severity=error\n          var handledState = {\n            severity: 'error',\n            unhandled: true,\n            severityReason: {\n              type: 'unhandledException'\n            }\n          };\n          var event; // window.onerror can be called in a number of ways. This big if-else is how we\n          // figure out which arguments were supplied, and what kind of values it received.\n\n          if (error) {\n            // if the last parameter (error) was supplied, this is a modern browser's\n            // way of saying \"this value was thrown and not caught\"\n            event = client.Event.create(error, true, handledState, 'window onerror', 1);\n            decorateStack(event.errors[0].stacktrace, url, lineNo, charNo);\n          } else if ( // This complex case detects \"error\" events that are typically synthesised\n          // by jquery's trigger method (although can be created in other ways). In\n          // order to detect this:\n          // - the first argument (message) must exist and be an object (most likely it's a jQuery event)\n          // - the second argument (url) must either not exist or be something other than a string (if it\n          //    exists and is not a string, it'll be the extraParameters argument from jQuery's trigger()\n          //    function)\n          // - the third, fourth and fifth arguments must not exist (lineNo, charNo and error)\n          typeof messageOrEvent === 'object' && messageOrEvent !== null && (!url || typeof url !== 'string') && !lineNo && !charNo && !error) {\n            // The jQuery event may have a \"type\" property, if so use it as part of the error message\n            var name = messageOrEvent.type ? \"Event: \" + messageOrEvent.type : 'Error'; // attempt to find a message from one of the conventional properties, but\n            // default to empty string (the event will fill it with a placeholder)\n\n            var message = messageOrEvent.message || messageOrEvent.detail || '';\n            event = client.Event.create({\n              name: name,\n              message: message\n            }, true, handledState, 'window onerror', 1); // provide the original thing onerror received – not our error-like object we passed to _notify\n\n            event.originalError = messageOrEvent; // include the raw input as metadata – it might contain more info than we extracted\n\n            event.addMetadata('window onerror', {\n              event: messageOrEvent,\n              extraParameters: url\n            });\n          } else {\n            // Lastly, if there was no \"error\" parameter this event was probably from an old\n            // browser that doesn't support that. Instead we need to generate a stacktrace.\n            event = client.Event.create(messageOrEvent, true, handledState, 'window onerror', 1);\n            decorateStack(event.errors[0].stacktrace, url, lineNo, charNo);\n          }\n\n          client._notify(event);\n        }\n\n        if (typeof prevOnError === 'function') prevOnError.apply(this, arguments);\n      }\n\n      var prevOnError = win.onerror;\n      win.onerror = onerror;\n    }\n  };\n}; // Sometimes the stacktrace has less information than was passed to window.onerror.\n// This function will augment the first stackframe with any useful info that was\n// received as arguments to the onerror callback.\n\n\nvar decorateStack = function (stack, url, lineNo, charNo) {\n  if (!stack[0]) stack.push({});\n  var culprit = stack[0];\n  if (!culprit.file && typeof url === 'string') culprit.file = url;\n  if (!culprit.lineNumber && isActualNumber(lineNo)) culprit.lineNumber = lineNo;\n\n  if (!culprit.columnNumber) {\n    if (isActualNumber(charNo)) {\n      culprit.columnNumber = charNo;\n    } else if (window.event && isActualNumber(window.event.errorCharacter)) {\n      culprit.columnNumber = window.event.errorCharacter;\n    }\n  }\n};\n\nvar isActualNumber = function (n) {\n  return typeof n === 'number' && String.call(n) !== 'NaN';\n};\n\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$iserror_20 = require('@bugsnag/core/lib/iserror'); */;\n\nvar _listener;\n/*\n * Automatically notifies Bugsnag when window.onunhandledrejection is called\n */\n\n\nvar _$unhandledRejection_55 = function (win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var plugin = {\n    load: function (client) {\n      if (!client._config.autoDetectErrors || !client._config.enabledErrorTypes.unhandledRejections) return;\n\n      var listener = function (evt) {\n        var error = evt.reason;\n        var isBluebird = false; // accessing properties on evt.detail can throw errors (see #394)\n\n        try {\n          if (evt.detail && evt.detail.reason) {\n            error = evt.detail.reason;\n            isBluebird = true;\n          }\n        } catch (e) {}\n\n        var event = client.Event.create(error, false, {\n          severity: 'error',\n          unhandled: true,\n          severityReason: {\n            type: 'unhandledPromiseRejection'\n          }\n        }, 'unhandledrejection handler', 1, client._logger);\n\n        if (isBluebird) {\n          _$map_16(event.errors[0].stacktrace, fixBluebirdStacktrace(error));\n        }\n\n        client._notify(event, function (event) {\n          if (_$iserror_20(event.originalError) && !event.originalError.stack) {\n            var _event$addMetadata;\n\n            event.addMetadata('unhandledRejection handler', (_event$addMetadata = {}, _event$addMetadata[Object.prototype.toString.call(event.originalError)] = {\n              name: event.originalError.name,\n              message: event.originalError.message,\n              code: event.originalError.code\n            }, _event$addMetadata));\n          }\n        });\n      };\n\n      if ('addEventListener' in win) {\n        win.addEventListener('unhandledrejection', listener);\n      } else {\n        win.onunhandledrejection = function (reason, promise) {\n          listener({\n            detail: {\n              reason: reason,\n              promise: promise\n            }\n          });\n        };\n      }\n\n      _listener = listener;\n    }\n  };\n\n  if (false) {}\n\n  return plugin;\n}; // The stack parser on bluebird stacks in FF get a suprious first frame:\n//\n// Error: derp\n//   b@http://localhost:5000/bluebird.html:22:24\n//   a@http://localhost:5000/bluebird.html:18:9\n//   @http://localhost:5000/bluebird.html:14:9\n//\n// results in\n//   […]\n//     0: Object { file: \"Error: derp\", method: undefined, lineNumber: undefined, … }\n//     1: Object { file: \"http://localhost:5000/bluebird.html\", method: \"b\", lineNumber: 22, … }\n//     2: Object { file: \"http://localhost:5000/bluebird.html\", method: \"a\", lineNumber: 18, … }\n//     3: Object { file: \"http://localhost:5000/bluebird.html\", lineNumber: 14, columnNumber: 9, … }\n//\n// so the following reduce/accumulator function removes such frames\n//\n// Bluebird pads method names with spaces so trim that too…\n// https://github.com/petkaantonov/bluebird/blob/b7f21399816d02f979fe434585334ce901dcaf44/src/debuggability.js#L568-L571\n\n\nvar fixBluebirdStacktrace = function (error) {\n  return function (frame) {\n    if (frame.file === error.toString()) return;\n\n    if (frame.method) {\n      frame.method = frame.method.replace(/^\\s+/, '');\n    }\n  };\n};\n\nvar _$notifier_2 = {};\nvar name = 'Bugsnag JavaScript';\nvar version = '7.16.1';\nvar url = 'https://github.com/bugsnag/bugsnag-js';\n\n/* removed: var _$Client_4 = require('@bugsnag/core/client'); */;\n\n/* removed: var _$Event_6 = require('@bugsnag/core/event'); */;\n\n/* removed: var _$Session_35 = require('@bugsnag/core/session'); */;\n\n/* removed: var _$Breadcrumb_3 = require('@bugsnag/core/breadcrumb'); */;\n\n/* removed: var _$map_16 = require('@bugsnag/core/lib/es-utils/map'); */;\n\n/* removed: var _$keys_15 = require('@bugsnag/core/lib/es-utils/keys'); */;\n\n/* removed: var _$assign_11 = require('@bugsnag/core/lib/es-utils/assign'); */; // extend the base config schema with some browser-specific options\n\n\nvar __schema_2 = _$assign_11({}, _$config_5.schema, _$config_1);\n\n/* removed: var _$onerror_54 = require('@bugsnag/plugin-window-onerror'); */;\n\n/* removed: var _$unhandledRejection_55 = require('@bugsnag/plugin-window-unhandled-rejection'); */;\n\n/* removed: var _$app_38 = require('@bugsnag/plugin-app-duration'); */;\n\n/* removed: var _$device_40 = require('@bugsnag/plugin-browser-device'); */;\n\n/* removed: var _$context_39 = require('@bugsnag/plugin-browser-context'); */;\n\n/* removed: var _$request_44 = require('@bugsnag/plugin-browser-request'); */;\n\n/* removed: var _$throttle_52 = require('@bugsnag/plugin-simple-throttle'); */;\n\n/* removed: var _$consoleBreadcrumbs_47 = require('@bugsnag/plugin-console-breadcrumbs'); */;\n\n/* removed: var _$networkBreadcrumbs_51 = require('@bugsnag/plugin-network-breadcrumbs'); */;\n\n/* removed: var _$navigationBreadcrumbs_50 = require('@bugsnag/plugin-navigation-breadcrumbs'); */;\n\n/* removed: var _$interactionBreadcrumbs_49 = require('@bugsnag/plugin-interaction-breadcrumbs'); */;\n\n/* removed: var _$inlineScriptContent_48 = require('@bugsnag/plugin-inline-script-content'); */;\n\n/* removed: var _$session_45 = require('@bugsnag/plugin-browser-session'); */;\n\n/* removed: var _$clientIp_46 = require('@bugsnag/plugin-client-ip'); */;\n\n/* removed: var _$stripQueryString_53 = require('@bugsnag/plugin-strip-query-string'); */; // delivery mechanisms\n\n\n/* removed: var _$delivery_36 = require('@bugsnag/delivery-x-domain-request'); */;\n\n/* removed: var _$delivery_37 = require('@bugsnag/delivery-xml-http-request'); */;\n\nvar Bugsnag = {\n  _client: null,\n  createClient: function (opts) {\n    // handle very simple use case where user supplies just the api key as a string\n    if (typeof opts === 'string') opts = {\n      apiKey: opts\n    };\n    if (!opts) opts = {};\n    var internalPlugins = [// add browser-specific plugins\n    _$app_38, _$device_40(), _$context_39(), _$request_44(), _$throttle_52, _$session_45, _$clientIp_46, _$stripQueryString_53, _$onerror_54(), _$unhandledRejection_55(), _$navigationBreadcrumbs_50(), _$interactionBreadcrumbs_49(), _$networkBreadcrumbs_51(), _$consoleBreadcrumbs_47, // this one added last to avoid wrapping functionality before bugsnag uses it\n    _$inlineScriptContent_48()]; // configure a client with user supplied options\n\n    var bugsnag = new _$Client_4(opts, __schema_2, internalPlugins, {\n      name: name,\n      version: version,\n      url: url\n    }); // set delivery based on browser capability (IE 8+9 have an XDomainRequest object)\n\n    bugsnag._setDelivery(window.XDomainRequest ? _$delivery_36 : _$delivery_37);\n\n    bugsnag._logger.debug('Loaded!');\n\n    bugsnag.leaveBreadcrumb('Bugsnag loaded', {}, 'state');\n    return bugsnag._config.autoTrackSessions ? bugsnag.startSession() : bugsnag;\n  },\n  start: function (opts) {\n    if (Bugsnag._client) {\n      Bugsnag._client._logger.warn('Bugsnag.start() was called more than once. Ignoring.');\n\n      return Bugsnag._client;\n    }\n\n    Bugsnag._client = Bugsnag.createClient(opts);\n    return Bugsnag._client;\n  }\n};\n_$map_16(['resetEventCount'].concat(_$keys_15(_$Client_4.prototype)), function (m) {\n  if (/^_/.test(m)) return;\n\n  Bugsnag[m] = function () {\n    if (!Bugsnag._client) return console.log(\"Bugsnag.\" + m + \"() was called before Bugsnag.start()\");\n    Bugsnag._client._depth += 1;\n\n    var ret = Bugsnag._client[m].apply(Bugsnag._client, arguments);\n\n    Bugsnag._client._depth -= 1;\n    return ret;\n  };\n});\n_$notifier_2 = Bugsnag;\n_$notifier_2.Client = _$Client_4;\n_$notifier_2.Event = _$Event_6;\n_$notifier_2.Session = _$Session_35;\n_$notifier_2.Breadcrumb = _$Breadcrumb_3; // Export a \"default\" property for compatibility with ESM imports\n\n_$notifier_2[\"default\"] = Bugsnag;\n\nreturn _$notifier_2;\n\n});\n//# sourceMappingURL=bugsnag.js.map\n\n\n//# sourceURL=webpack:///./node_modules/@bugsnag/browser/dist/bugsnag.js?")},"./node_modules/@bugsnag/js/browser/notifier.js":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! @bugsnag/browser */ "./node_modules/@bugsnag/browser/dist/bugsnag.js")\n\n\n//# sourceURL=webpack:///./node_modules/@bugsnag/js/browser/notifier.js?')},"./node_modules/axios/index.js":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");\n\n//# sourceURL=webpack:///./node_modules/axios/index.js?')},"./node_modules/axios/lib/adapters/xhr.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar settle = __webpack_require__(/*! ./../core/settle */ \"./node_modules/axios/lib/core/settle.js\");\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \"./node_modules/axios/lib/core/buildFullPath.js\");\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \"./node_modules/axios/lib/helpers/parseHeaders.js\");\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \"./node_modules/axios/lib/helpers/isURLSameOrigin.js\");\nvar createError = __webpack_require__(/*! ../core/createError */ \"./node_modules/axios/lib/core/createError.js\");\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = __webpack_require__(/*! ./../helpers/cookies */ \"./node_modules/axios/lib/helpers/cookies.js\");\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/adapters/xhr.js?")},"./node_modules/axios/lib/axios.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");\nvar bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");\nvar Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");\nvar defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/axios.js?')},"./node_modules/axios/lib/cancel/Cancel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/Cancel.js?")},"./node_modules/axios/lib/cancel/CancelToken.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Cancel = __webpack_require__(/*! ./Cancel */ \"./node_modules/axios/lib/cancel/Cancel.js\");\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/CancelToken.js?")},"./node_modules/axios/lib/cancel/isCancel.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/cancel/isCancel.js?")},"./node_modules/axios/lib/core/Axios.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \"./node_modules/axios/lib/helpers/buildURL.js\");\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \"./node_modules/axios/lib/core/InterceptorManager.js\");\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \"./node_modules/axios/lib/core/dispatchRequest.js\");\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \"./node_modules/axios/lib/core/mergeConfig.js\");\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/Axios.js?")},"./node_modules/axios/lib/core/InterceptorManager.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/InterceptorManager.js?')},"./node_modules/axios/lib/core/buildFullPath.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/buildFullPath.js?')},"./node_modules/axios/lib/core/createError.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \"./node_modules/axios/lib/core/enhanceError.js\");\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/createError.js?")},"./node_modules/axios/lib/core/dispatchRequest.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\nvar transformData = __webpack_require__(/*! ./transformData */ \"./node_modules/axios/lib/core/transformData.js\");\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \"./node_modules/axios/lib/cancel/isCancel.js\");\nvar defaults = __webpack_require__(/*! ../defaults */ \"./node_modules/axios/lib/defaults.js\");\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/dispatchRequest.js?")},"./node_modules/axios/lib/core/enhanceError.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/enhanceError.js?")},"./node_modules/axios/lib/core/mergeConfig.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/axios/lib/utils.js\");\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',\n    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath'\n  ];\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {\n    if (utils.isObject(config2[prop])) {\n      config[prop] = utils.deepMerge(config1[prop], config2[prop]);\n    } else if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (utils.isObject(config1[prop])) {\n      config[prop] = utils.deepMerge(config1[prop]);\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys);\n\n  var otherKeys = Object\n    .keys(config2)\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {\n    if (typeof config2[prop] !== 'undefined') {\n      config[prop] = config2[prop];\n    } else if (typeof config1[prop] !== 'undefined') {\n      config[prop] = config1[prop];\n    }\n  });\n\n  return config;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/mergeConfig.js?")},"./node_modules/axios/lib/core/settle.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar createError = __webpack_require__(/*! ./createError */ \"./node_modules/axios/lib/core/createError.js\");\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/settle.js?")},"./node_modules/axios/lib/core/transformData.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/core/transformData.js?')},"./node_modules/axios/lib/defaults.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/axios/lib/utils.js\");\nvar normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ \"./node_modules/axios/lib/helpers/normalizeHeaderName.js\");\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = __webpack_require__(/*! ./adapters/xhr */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = __webpack_require__(/*! ./adapters/http */ \"./node_modules/axios/lib/adapters/xhr.js\");\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/axios/lib/defaults.js?")},"./node_modules/axios/lib/helpers/bind.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/bind.js?")},"./node_modules/axios/lib/helpers/buildURL.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/buildURL.js?")},"./node_modules/axios/lib/helpers/combineURLs.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/combineURLs.js?")},"./node_modules/axios/lib/helpers/cookies.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/cookies.js?")},"./node_modules/axios/lib/helpers/isAbsoluteURL.js":function(module,exports,__webpack_require__){"use strict";eval('\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isAbsoluteURL.js?')},"./node_modules/axios/lib/helpers/isURLSameOrigin.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/isURLSameOrigin.js?")},"./node_modules/axios/lib/helpers/normalizeHeaderName.js":function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/normalizeHeaderName.js?')},"./node_modules/axios/lib/helpers/parseHeaders.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar utils = __webpack_require__(/*! ./../utils */ \"./node_modules/axios/lib/utils.js\");\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/parseHeaders.js?")},"./node_modules/axios/lib/helpers/spread.js":function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/helpers/spread.js?")},"./node_modules/axios/lib/utils.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nvar bind = __webpack_require__(/*! ./helpers/bind */ \"./node_modules/axios/lib/helpers/bind.js\");\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Function equal to merge with the difference being that no reference\n * to original objects is kept.\n *\n * @see merge\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction deepMerge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = deepMerge(result[key], val);\n    } else if (typeof val === 'object') {\n      result[key] = deepMerge({}, val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  deepMerge: deepMerge,\n  extend: extend,\n  trim: trim\n};\n\n\n//# sourceURL=webpack:///./node_modules/axios/lib/utils.js?")},"./node_modules/process/browser.js":function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')}});